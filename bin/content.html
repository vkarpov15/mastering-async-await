
    <html>
      <head>
        <link href='http://fonts.googleapis.com/css?family=Titillium+Web' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>

        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
          html {
  font-family: 'Roboto';
  font-size: 18pt;
  margin: 0px;
}

a {
  text-decoration: none;
  color: #6699cc;
}

h1 {
  padding-top: 3px;
  margin-top: 0px;
  font-size: 2em;
}

h2 {
  font-size: 1.5em;
}

.chapter {
  margin-top: 1px;
  page-break-before: always;
  line-height: 1.5em;
  width: 1042px;
}

.chapter img {
  width: 1042px;
}

.page-break {
  page-break-before: always;
}

pre {
  border: 1px solid #dfdfdf;
  padding: 15px;
}

code {
  font-family: 'Droid Sans Mono';
}

p code {
  color: #232323;
  font-size: 0.9em;
  padding: 1px 2px 2px 2px;
  color: #c7254e;
  background-color: #f6f6f6;
}

li code {
  color: #232323;
  font-size: 0.9em;
  padding: 1px 2px 2px 2px;
  color: #c7254e;
  background-color: #f6f6f6;
}

h3 code {
  color: #232323;
  font-size: 0.9em;
  padding: 1px 2px 2px 2px;
  color: #c7254e;
  background-color: #f6f6f6;
}

.example-header-wrap {
  position: relative;
  height: 0px;
}

.space-example-header {
  font-size: 0.25em;
}

.example-header {
  border: 1px solid #dfdfdf;
  top: -15px;
  padding-top: 0px;
  height: 1em;
  padding: 1px;
  position: absolute;
  width: 7em;
  text-align: center;
  color: #666;
  font-size: 0.5em;
  line-height: 1em;
}

.toc a {
  font-size: 18pt;
  color: #232323;
  float: right;
  font-weight: bold;
}

.toc ol {
  padding-left: 2.5em;
}

.toc li {
  margin-left: 0px;
  line-height: 1.5em;
}

.toc a::after {
  content: '';
  clear: both;
  display: table;
}

svg {
  width: 800px;
  margin-left: 100px;
  margin-bottom: 15px;
}

/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-javadoc {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.css .rule .hljs-keyword,
.hljs-winutils,
.nginx .hljs-title,
.hljs-subst,
.hljs-request,
.hljs-status {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-hexcolor,
.ruby .hljs-constant {
  color: #008080;
}

.hljs-string,
.hljs-tag .hljs-value,
.hljs-phpdoc,
.hljs-dartdoc,
.tex .hljs-formula {
  color: #d14;
}

.hljs-title,
.hljs-id,
.scss .hljs-preprocessor {
  color: #900;
  font-weight: bold;
}

.hljs-list .hljs-keyword,
.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.vhdl .hljs-literal,
.tex .hljs-command {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-tag .hljs-title,
.hljs-rules .hljs-property,
.django .hljs-tag .hljs-keyword {
  color: #000080;
  font-weight: normal;
}

.hljs-attribute,
.hljs-variable,
.lisp .hljs-body {
  color: #008080;
}

.hljs-regexp {
  color: #009926;
}

.hljs-symbol,
.ruby .hljs-symbol .hljs-string,
.lisp .hljs-keyword,
.clojure .hljs-keyword,
.scheme .hljs-keyword,
.tex .hljs-special,
.hljs-prompt {
  color: #990073;
}

.hljs-built_in {
  color: #0086b3;
}

.hljs-preprocessor,
.hljs-pragma,
.hljs-pi,
.hljs-doctype,
.hljs-shebang,
.hljs-cdata {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.diff .hljs-change {
  background: #0086b3;
}

.hljs-chunk {
  color: #aaa;
}

        </style>
      </head>
      <body>
        <div class="toc">
          <h1 id="table-of-contents">Table of Contents</h1>
<h2 id="0-how-to-use-this-book-1-page-2-">0. How To Use This Book <a href="#page=2">1</a></h2>
<h2 id="1-async-await-the-good-parts-4-page-5-">1. Async/Await: The Good Parts <a href="#page=5">4</a></h2>
<ol>
<li>Return Values <a href="#page=7">6</a></li>
<li>Error Handling <a href="#page=10">9</a></li>
<li>Retrying Failed Requests <a href="#page=13">12</a></li>
<li>Exercise 1: HTTP Request Loops <a href="#page=15">14</a></li>
<li>Exercise 2: Retrying Failed Requests <a href="#page=16">15</a></li>
</ol>
<h2 id="2-promises-from-the-ground-up-16-page-17-">2. Promises From The Ground Up <a href="#page=17">16</a></h2>
<ol>
<li>Promise Chaining <a href="#page=20">19</a></li>
<li><code>catch()</code> and Other Helpers <a href="#page=24">23</a></li>
<li>Exercise 1: Promise Chains in Action <a href="#page=27">26</a></li>
<li>Exercise 2: <code>Promise.race()</code> <a href="#page=28">27</a></li>
</ol>
<h2 id="3-async-await-internals-28-page-29-">3. Async/Await Internals <a href="#page=29">28</a></h2>
<ol>
<li><code>await</code> vs <code>return</code> <a href="#page=30">29</a></li>
<li>Concurrency <a href="#page=32">31</a></li>
<li>Async/Await vs Generators <a href="#page=34">33</a></li>
<li>Core Principles <a href="#page=36">35</a></li>
<li>Exercise 1: Implementing Custom Thenables <a href="#page=39">38</a></li>
<li>Exercise 2: Async <code>forEach()</code> <a href="#page=40">39</a></li>
</ol>
<h2 id="4-async-await-in-the-wild-40-page-41-">4. Async/Await in the Wild <a href="#page=41">40</a></h2>
<ol>
<li>With Mocha <a href="#page=42">41</a></li>
<li>With Express <a href="#page=43">42</a></li>
<li>With MongoDB <a href="#page=45">44</a></li>
<li>With Redux <a href="#page=47">46</a></li>
<li>With React <a href="#page=49">48</a></li>
<li>Exercise 1: Does X Support Async/Await? <a href="#page=51">50</a></li>
<li>Exercise 2: WebSocket Integration <a href="#page=52">51</a></li>
</ol>
<h2 id="5-moving-on-52-page-53-">5. Moving On <a href="#page=53">52</a></h2>

        </div>
        <div class="chapter">
          <h1 id="how-to-use-this-book">How To Use This Book</h1>
<p><a href="http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js.html">Async/await</a>
is the single most valuable feature to land in the JavaScript language spec in the last 15 years. The event loop and asynchronous programming in general are exceptional for
building GUIs and servers, but callbacks make error handling tedious and code hard to
read. For example, when <a href="https://risingstack.com/">RisingStack</a> asked Node.js developers
what they struggled with in 2017, asynchronous programming topped the list.</p>
<p><img src="https://i.imgur.com/YQ58zIl.png"></p>
<p>Async/await promises to make asynchronous code as clean and easy to
read as synchronous code in most use cases. Tangled promise chains and complex
user-land libraries like
<a href="https://www.npmjs.com/package/async">async</a> can be replaced with <code>for</code> loops,
<code>if</code> statements, and <code>try/catch</code> blocks that even the most junior of engineers can
make sense of.</p>
<p>The following <a href="https://www.hacksparrow.com/node-js-async-programming.html">JavaScript from a 2012 blog post</a> is a typical
example of where code goes wrong with callbacks. This code works,
but it has a lot of error handling boilerplate and deeply nested <code>if</code> statements
that obfuscate the actual logic. Wrapping your mind around it takes a while,
and proper error handling means copy/pasting <code>if (err != null)</code> into every
callback.</p>
<div class="page-break"></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWikipediaHeaders</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// i. check if headers.txt exists</span>
  fs.stat(<span class="hljs-string">'./headers.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, stats</span>) </span>{
    <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) { <span class="hljs-keyword">throw</span> err; }
    <span class="hljs-keyword">if</span> (stats == <span class="hljs-literal">undefined</span>) {
      <span class="hljs-comment">// ii. fetch the HTTP headers</span>
      <span class="hljs-keyword">var</span> options = { <span class="hljs-attr">host</span>: <span class="hljs-string">'www.wikipedia.org'</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">80</span> };
      http.get(options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) </span>{
        <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) { <span class="hljs-keyword">throw</span> err; }
        <span class="hljs-keyword">var</span> headers = <span class="hljs-built_in">JSON</span>.stringify(res.headers);
        <span class="hljs-comment">// iii. write the headers to headers.txt</span>
        fs.writeFile(<span class="hljs-string">'./headers.txt'</span>, headers, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
          <span class="hljs-keyword">if</span> (err != <span class="hljs-literal">null</span>) { <span class="hljs-keyword">throw</span> err; }
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Great Success!'</span>);
        });
      });    
    } <span class="hljs-keyword">else</span> { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'headers already collected'</span>); }
  });
}
</code></pre>
<p>Below is the same code using async/await, assuming that <code>stat()</code>, <code>get()</code>, and
<code>writeFile()</code> are properly promisified.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWikipediaHeaders</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> stat(<span class="hljs-string">'./headers.txt'</span>) != <span class="hljs-literal">null</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'headers already collected'</span>);
  }
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> get({ <span class="hljs-attr">host</span>: <span class="hljs-string">'www.wikipedia.org'</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">80</span> });
  <span class="hljs-keyword">await</span> writeFile(<span class="hljs-string">'./headers.txt'</span>, <span class="hljs-built_in">JSON</span>.stringify(res.headers));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Great success!'</span>);
}
</code></pre>
<p>You might not think async/await is a big deal. You might even think async/await
is a bad idea. I&#39;ve been in your shoes: when I first learned about async/await in
2013, I thought it was unnecessary at best. But when I
started working with generator-based coroutines (the 2015 predecessor to async/await),
I was shocked at how quickly server crashes due to
<code>TypeError: Cannot read property &#39;x&#39; of undefined</code> vanished. By the time async/await
became part of the JavaScript language spec in 2017, async/await was an
indispensable part of my dev practice.</p>
<p>Just because async/await is now officially part of JavaScript doesn&#39;t mean
the world is all sunshine and rainbows. Async/await is a new pattern that
promises to make day-to-day development work easier, but, like any pattern, you
need to understand it or you&#39;ll do more harm than good. If your async/await
code is a patchwork of copy/pasted StackOverflow answers, you&#39;re just trading
callback hell for the newly minted <a href="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c">async/await hell</a>.</p>
<p>The purpose of this book is to take you from someone who is casually acquainted
with promises and async/await to someone who is comfortable building and debugging
a complex app whose core logic is built on async/await. This book is only
52 pages and is meant to be read in about 2 hours total. You may read it all in
one sitting, but you would be better served reading one chapter at a time,
studying the exercises at the end, and getting a good night&#39;s sleep in between
chapters to really internalize the information.</p>
<p>This book is broken up into 4 chapters. Each chapter is 12 pages, including
exercises at the end of each chapter that highlight key lessons from the chapter.
The exercises require more thought than
code and should be easy to answer within a few minutes.</p>
<p>The first 3 chapters are focused on promise and async/await fundamentals, and strive
to avoid frameworks and outside dependencies. In particular, the code samples and exercises are meant to run in Node.js 8.x and  will <strong>not</strong> use any transpilers
like Babel.</p>
<p>In the interest of providing realistic examples,
the code samples will use the <code>superagent</code> module for making HTTP requests. The
4th chapter will discuss integrating async/await with some common
npm modules.</p>
<p>If you find any issues with the code samples or exercises,
please report them at <a href="https://github.com/vkarpov15/mastering-async-await-issues">github.com/vkarpov15/mastering-async-await-issues</a>.</p>
<p>Are you ready to master async/await? Let&#39;s get started!</p>

        </div>
        <div class="chapter">
          <h1 id="async-await-the-good-parts">Async/Await: The Good Parts</h1>
<p>The <code>async</code> and <code>await</code> keywords are new additions to JavaScript as part of the
2017 edition of the language specification. The <code>async</code> keyword modifies a function,
either a normal <code>function() {}</code> or an arrow function <code>() =&gt; {}</code>, to mark it as an
<em>async function</em>. In an async function, you can use the <code>await</code> keyword to pause
the function&#39;s execution until a promise settles. In the below function, the <code>await</code>
keyword pauses the function&#39;s execution for approximately 1 second.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.1</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This function will print "Hello, World!" after 1 second.</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();
</code></pre>
<p>You can use the <code>await</code> keyword anywhere in the body of an async function. This means
you can use <code>await</code> in <code>if</code> statements, <code>for</code> loops, and <code>try/catch</code> blocks. Below
is another way to pause an async function&#39;s execution for about 1 second.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.2</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Wait for 100ms 10 times. This function also prints after 1 second.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">100</span>));
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
}

test();
</code></pre>
<p>There is one major restriction for using <code>await</code>: you can only use <code>await</code>
within the body of a function that&#39;s marked <code>async</code>. The following code throws a
<code>SyntaxError</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.3</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-comment">// SyntaxError: Unexpected identifier</span>
  <span class="hljs-keyword">await</span> p;
}

test();
</code></pre>
<p>In particular, you can&#39;t use <code>await</code> in a closure embedded in an async function, unless
the closure is also an async function. The below code also throws a <code>SyntaxError</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.4</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'test'</span>);
  assert.doesNotThrow(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// "SyntaxError: Unexpected identifier" because the above function</span>
    <span class="hljs-comment">// is **not** marked async. "Closure" = function inside a function</span>
    <span class="hljs-keyword">await</span> p;
  });
}
</code></pre>
<p>As long as you don&#39;t create a new function, you can use <code>await</code> underneath any
number of <code>for</code> loops and <code>if</code> statements.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.5</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Convoluted way to print out "Hello, World!" once per second by</span>
    <span class="hljs-comment">// pausing execution for 200ms 5 times</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">200</span>));
      }
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
  }
}
</code></pre>
<div class="page-break"></div>

<h2 id="return-values">Return Values</h2>
<p>You can use <code>async/await</code> for more than just pausing execution. The return
value of <code>await</code> is the value the promise is fulfilled with. This means you can
assign a variable to an asynchronously-computed value in code that looks
synchronous.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.6</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// You can `await` on a non-promise without getting an error.</span>
  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-string">'Hello World!'</span>;
  <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// "Hello, World!"</span>

  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    <span class="hljs-comment">// This promise resolves to "Hello, World!" after 1s</span>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">1000</span>);
  });
  res = <span class="hljs-keyword">await</span> promise;
  <span class="hljs-comment">// Prints "Hello, World!". `res` is equal to the value the</span>
  <span class="hljs-comment">// promise resolved to.</span>
  <span class="hljs-built_in">console</span>.log(res);

  <span class="hljs-comment">// Prints "Hello, World!". You can use `await` in function params!</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> promise);
}
</code></pre>
<p>An async function <strong>always</strong> returns a promise. When you <code>return</code> from an async
function, JavaScript resolves the promise to the value you returned. This means
calling async functions from other async functions is very natural. You can
<code>await</code> on the async function call and get the async function&#39;s &quot;return value&quot;.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.7</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-comment">// "Hello, World" is the _resolved value_ for this function call</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, World!'</span>;
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Prints "Hello, World!" after 1s. `computeValue` returns a promise!</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> computeValue());
}
</code></pre>
<p>This book will refer to the value you <code>return</code> from an async function as the
<em>resolved value</em>. In <code>computeValue</code> above, &quot;Hello, World!&quot; is the resolved
value, <code>computeValue()</code> still returns a promise. This distinction is subtle
but important: the value you <code>return</code> from an async function body is <strong>not</strong>
the value that an async function call like <code>computeValue()</code> without <code>await</code>
returns.</p>
<p>You can also return a promise from an async function. In that case, the
promise the async function returns will be fulfilled or rejected whenever the
resolved value promise is fulfilled or rejected. Below is another async function that fulfills to &#39;Hello, World!&#39; after 1 second:</p>
<div class="example-header-wrap"><div class="example-header">Example 1.8</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// The resolved value is a promise. The promise returned from</span>
  <span class="hljs-comment">// `computeValue()` will be fulfilled with 'Hello, World!'</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">'Hello, World!'</span>));
  }, <span class="hljs-number">1000</span>);
}
</code></pre>
<p>If you <code>return</code> a promise from an async function, the resolved value will
still not equal the return value. The below example demonstrates that the
<code>resolvedValue</code> promise that the function body returns is not the same as
the return value from <code>computeValue()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.9</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> resolvedValue = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello, World!'</span>);
<span class="hljs-keyword">const</span> computeValue = <span class="hljs-keyword">async</span> () =&gt; resolvedValue;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// No `await` below, so `returnValue` will be a promise</span>
  <span class="hljs-keyword">const</span> returnValue = computeValue();
  <span class="hljs-comment">// `false`. The return value and resolved value are always different</span>
  <span class="hljs-built_in">console</span>.log(returnValue === resolvedValue);
}
</code></pre>
<p>Async/await beginners often mistakenly think they need to <code>return</code> a promise
from an async function. They likely read that an async function always returns
a promise and think they&#39;re responsible for returning a promise. An async function
always returns a promise, but, like in example 1.9, JavaScript creates the returned promise for you.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.10</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Adding `Promise.resolve()` below is unnecessary. It adds</span>
  <span class="hljs-comment">// perf overhead because you're creating an unnecessary promise.</span>
  <span class="hljs-comment">// "Unnecessary code is not as harmless as I used to think. It</span>
  <span class="hljs-comment">// sends the misleading signal that it's necessary." - Paul Graham</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello, World!'</span>);
}
</code></pre>
<div class="page-break"></div>

<h2 id="error-handling">Error Handling</h2>
<p>One of the most important properties of async/await is that you can use <code>try/catch</code>
to handle asynchronous errors. Remember that a promise may be either fulfilled
or rejected. When a promise <code>p</code> is fulfilled, JavaScript evaluates <code>await p</code>
to the promise&#39;s value. What about if <code>p</code> is rejected?</p>
<div class="example-header-wrap"><div class="example-header">Example 1.11</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
    <span class="hljs-comment">// The below `await` throws</span>
    <span class="hljs-keyword">await</span> p;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(err.message); <span class="hljs-comment">// "Oops!"</span>
  }
}
</code></pre>
<p>If <code>p</code> is rejected, <code>await p</code> throws an error that you can catch with a
normal JavaScript <code>try/catch</code>. Note that the <code>await</code> statement is what throws
an error, <strong>not</strong> the promise instantiation.</p>
<p>This <code>try/catch</code> behavior is a powerful tool for consolidating error handling.
The <code>try/catch</code> block above can catch synchronous errors as well as asynchronous
ones. Suppose you have code that throws a <code>TypeError: cannot read property &#39;x&#39; of undefined</code> error:</p>
<div class="example-header-wrap"><div class="example-header">Example 1.12</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> bad = <span class="hljs-literal">undefined</span>;
    bad.x;
    <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
    <span class="hljs-keyword">await</span> p;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// "cannot read property 'x' of undefined"</span>
    <span class="hljs-built_in">console</span>.log(error.message);
  }
}
</code></pre>
<p>In callback-based code, you had to watch out for synchronous errors like <code>TypeError</code>
separately from asynchronous errors. This lead to a lot of server crashes and
red text in Chrome consoles, because discipline doesn&#39;t scale.</p>
<p>Consider using a callback-based approach instead of async/await. Suppose you have
a black-box function <code>test()</code> that takes a single parameter, a <code>callback</code>.
If you want to ensure you catch every possible error, you need 2 <code>try/catch</code>
calls: one around <code>test()</code> and one around <code>callback()</code>. You also need to check
whether <code>test()</code> called your callback with an error. In other words, every
single async operation needs 3 distinct error handling patterns!</p>
<div class="example-header-wrap"><div class="example-header">Example 1.13</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testWrapper</span>(<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// There might be a sync error in `test()`</span>
    test(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
      <span class="hljs-comment">// `test()` might also call the callback with an error</span>
      <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-keyword">return</span> callback(error);
      }
      <span class="hljs-comment">// And you also need to be careful that accessing `res.x` doesn't</span>
      <span class="hljs-comment">// throw **and** calling `callback()` doesn't throw.</span>
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, res.x);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">return</span> callback(error);
      }
    });
  }
}
</code></pre>
<p>When there&#39;s this much boilerplate for error handling, even the most rigorous
and disciplined developers end up missing a spot. The result is uncaught errors,
server downtime, and buggy user interfaces. Below is an equivalent example with
async/await. You can handle the 3 distinct error cases from example 1.12 with
a single pattern.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.14</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testWrapper</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// `try/catch` will catch sync errors in `test()`, async promise</span>
    <span class="hljs-comment">// rejections, and errors with accessing `res.x`.</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> test();
    <span class="hljs-keyword">return</span> res.x;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">throw</span> error;
  }
}
</code></pre>
<p>Let&#39;s take a look at how the <code>throw</code> keyword works with async functions now that
you&#39;ve seen how <code>try/catch</code> works. When you <code>throw</code> in an async function,
JavaScript will reject the returned promise.
Remember that the value you <code>return</code> from an async function is called the
resolved value. Similarly, this book will refer to the value you <code>throw</code> in
an async function as the <em>rejected value</em>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.15</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// `err` is the "rejected value"</span>
  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
  <span class="hljs-keyword">throw</span> err;
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> computeValue();
    <span class="hljs-comment">// Never runs</span>
    <span class="hljs-built_in">console</span>.log(res);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// "Oops!"</span>
  }
}
</code></pre>
<p>Remember that the <code>computeValue()</code> function call itself does <strong>not</strong> throw an
error in the <code>test()</code> function. The <code>await</code> keyword is what throws an error that
you can handle with <code>try/catch</code>. The below code will print &quot;No Error&quot; unless you
uncomment the <code>await</code> block.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.16</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
};

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> promise = computeValue();
    <span class="hljs-comment">// With the below line commented out, no error will be thrown</span>
    <span class="hljs-comment">// await promise;</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"No Error"</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(error.message); <span class="hljs-comment">// Won't run</span>
  }
}
</code></pre>
<div class="page-break"></div>

<p>Just because you can <code>try/catch</code> around a promise doesn&#39;t necessarily mean you
should. Since async functions return promises, you can also use <code>.catch()</code>:</p>
<div class="example-header-wrap"><div class="example-header">Example 1.17</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeValue</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
};

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> err = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">await</span> computeValue().catch(<span class="hljs-function"><span class="hljs-params">_err</span> =&gt;</span> { err = _err; });
  <span class="hljs-built_in">console</span>.log(err.message);
}
</code></pre>
<p>Both <code>try/catch</code> and <code>catch()</code> have their place. In particular, <code>catch()</code>
makes it easier to centralize your error handling. A common async/await
novice mistake is putting <code>try/catch</code> at the top of every single function.
If you want a common <code>handleError()</code> function to ensure you&#39;re handing all
errors, you&#39;re better off using <code>catch()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.18</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// If you find yourself doing this, stop!</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">/* Bunch of logic here */</span>
  } <span class="hljs-keyword">catch</span> (err) {
    handleError(err);
  }
}

<span class="hljs-comment">// Do this instead</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/* Bunch of logic here */</span>
}

fn2().catch(handleError);
</code></pre>
<div class="page-break"></div>

<h2 id="retrying-failed-requests">Retrying Failed Requests</h2>
<p>Let&#39;s tie together loops, return values, and error handling to handle a challenge
that&#39;s painful with callbacks: retrying failed requests. Suppose you had to make
HTTP requests to an unreliable API.</p>
<p>With callbacks or promise chains, retrying failed requests requires recursion,
and recursion is less readable than the synchronous alternative of writing
a <code>for</code> loop. Below is a simplified implementation of a <code>getWithRetry()</code> function
using callbacks and the <a href="https://www.npmjs.com/package/superagent"><code>superagent</code> HTTP client</a>.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.19</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWithRetry</span>(<span class="hljs-params">url, numRetries, callback, retriedCount</span>) </span>{
  retriedCount = retriedCount || <span class="hljs-number">0</span>;
  superagent.get(url).end(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
    <span class="hljs-keyword">if</span> (error) {
      <span class="hljs-keyword">if</span> (retriedCount &gt;= numRetries) { <span class="hljs-keyword">return</span> callback(error); }
      <span class="hljs-keyword">return</span> getWithRetry(url, numRetries, callback, retriedCount + <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, res.body);
  });
}
</code></pre>
<p>Recursion is subtle and tricky to understand relative to a loop.
Plus, the above code ignores the possibility of sync errors, because the
<code>try/catch</code> spaghetti highlighted in example 1.13 would make this example
unreadable. In short, this pattern is both brittle and cumbersome.</p>
<p>With async/await, you don&#39;t need recursion and you need one <code>try/catch</code> to
handle sync and async errors. The async/await implementation is built on <code>for</code>
loops, <code>try/catch</code>, and other constructs that should be familiar to even the
most junior of engineers.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.20</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWithRetry</span>(<span class="hljs-params">url, numRetries</span>) </span>{
  <span class="hljs-keyword">let</span> lastError = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numRetries; ++i) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Note that `await superagent.get(url).body` does **not** work</span>
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> superagent.get(url);
      <span class="hljs-comment">// Early return with async functions works as you'd expect</span>
      <span class="hljs-keyword">return</span> res.body;
    } <span class="hljs-keyword">catch</span> (error) {
      lastError = error;
    }
  }
  <span class="hljs-keyword">throw</span> lastError;
}
</code></pre>
<p>More generally, async/await makes executing async operations in series trivial.
For example, let&#39;s say you had to load a list of blog posts from an HTTP API
and then execute a separate HTTP request to load the comments for each blog
post. This example uses the excellent <a href="https://jsonplaceholder.typicode.com/">JSONPlaceholder API</a> that provides good test data.</p>
<div class="example-header-wrap"><div class="example-header">Example 1.21</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> root = <span class="hljs-string">'https://jsonplaceholder.typicode.com'</span>;
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/posts`</span>, <span class="hljs-number">3</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { id } <span class="hljs-keyword">of</span> posts) {
    <span class="hljs-keyword">const</span> comments =
      <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/comments?postId=<span class="hljs-subst">${id}</span>`</span>, <span class="hljs-number">3</span>);
    <span class="hljs-built_in">console</span>.log(comments);
  }
}
</code></pre>
<p>If this example seems trivial, that&#39;s good, because that&#39;s how programming
should be. The JavaScript community has created an incredible hodge-podge of
tools for executing asynchronous tasks in series, from <a href="https://caolan.github.io/async/docs.html#waterfall"><code>async.waterfall()</code></a> to <a href="https://www.npmjs.com/package/redux-saga">Redux sagas</a> to <a href="https://github.com/domenic/zones">zones</a> to <a href="https://www.npmjs.com/package/co">co</a>. Async/await makes all of these libraries
and more unnecessary. Do you even need <a href="https://www.codementor.io/vkarpov/beginner-s-guide-to-redux-middleware-du107uyud">Redux middleware</a> anymore?</p>
<p>This isn&#39;t the whole story with async/await. This chapter glossed over numerous
important details, including how promises integrate with async/await and
what happens when two asynchronous functions run simultaneously. Chapter 2
will focus on the internals of promises, including the difference between
&quot;resolved&quot; and &quot;fulfilled&quot;, and explain why promises are perfectly suited
for async/await.</p>
<div class="page-break"></div>

<h2 id="exercise-1-http-request-loops">Exercise 1: HTTP Request Loops</h2>
<p>The purpose of this exercise is to get comfortable with using
loops and <code>if</code> statements with async/await. You will need to use
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>fetch()</code> API</a>
to get a list of blog posts on
thecodebarbarian.com, and then
execute a separate <code>fetch()</code> to get the raw markdown <code>content</code>
for each blog post.</p>
<p>Below are the API endpoints. The API endpoints are hosted on
Google Cloud Functions at <code>https://us-central1-mastering-async-await.cloudfunctions.net</code>.</p>
<ul>
<li><code>/posts</code>
gets a list of blog posts. Below is an example post:</li>
</ul>
<pre><code>{ <span class="hljs-string">"src"</span>:<span class="hljs-string">"./lib/posts/20160304_circle_ci.md"</span>,
  <span class="hljs-string">"title"</span>:<span class="hljs-string">"Setting Up Circle CI With Node.js"</span>,
  <span class="hljs-string">"date"</span>:<span class="hljs-string">"2016-03-04T00:00:00.000Z"</span>,
  <span class="hljs-string">"tags"</span>:[<span class="hljs-string">"NodeJS"</span>],
  <span class="hljs-string">"id"</span>:<span class="hljs-number">51</span> }
</code></pre><ul>
<li><code>/post?id=${id}</code>
gets the markdown content of a blog post by its <code>id</code> property.
The above blog post has <code>id</code> = 0, so you can get its content from
this endpoint: <a href="https://us-central1-mastering-async-await.cloudfunctions.net/post?id=0"><code>https://us-central1-mastering-async-await.cloudfunctions.net/post?id=0</code></a>. Try opening this URL in your browser, the output looks
like this:</li>
</ul>
<pre><code>{<span class="hljs-string">"content"</span>:<span class="hljs-string">"*This post was featured as a guest blog post..."</span>}
</code></pre><p>Loop through the blog posts and find the id of the first post
whose <code>content</code> contains the string &quot;async/await hell&quot;.</p>
<p>Below is the starter code. You may copy this code and run it in Node.js using <a href="https://www.npmjs.com/package/node-fetch">the <code>node-fetch</code> npm module</a>, or you may complete this exercise in your browser
on CodePen at <a href="http://bit.ly/async-await-exercise-1"><code>http://bit.ly/async-await-exercise-1</code></a></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> root = <span class="hljs-string">'https://'</span> +
  <span class="hljs-string">'us-central1-mastering-async-await.cloudfunctions.net'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Example of using `fetch()` API</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/posts`</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> res.json());
}

run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));
</code></pre>
<div class="page-break"></div>

<h2 id="exercise-2-retrying-failed-requests">Exercise 2: Retrying Failed Requests</h2>
<p>The purpose of this exercise is to implement a function that retries failed
HTTP requests using async/await and <code>try/catch</code> to handle errors. This example
builds on the correct answer to exercise 1.1, but with the added caveat that
every other <code>fetch()</code> request fails.</p>
<p>For this exercise, you need to implement the <code>getWithRetry()</code> function below.
This function should <code>fetch()</code> the <code>url</code>, and if the request fails this
function should retry the request up to <code>numRetries</code> times. If you see
&quot;Correct answer: 76&quot;, congratulations, you completed this exercise.</p>
<p>Like exercise 1.1, you can complete this exercise locally by copying the
below code and using the <a href="https://www.npmjs.com/package/node-fetch"><code>node-fetch</code> npm module</a>.
You can also complete this exercise in your browser on CodePen at the following
url: <a href="http://bit.ly/async-await-exercise-2">http://bit.ly/async-await-exercise-2</a>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWithRetry</span>(<span class="hljs-params">url, numRetries</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(url).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json());
}

<span class="hljs-comment">// Correct answer for exercise 1.1 below</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> root = <span class="hljs-string">'https://'</span> +
    <span class="hljs-string">'us-central1-mastering-async-await.cloudfunctions.net'</span>;
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/posts`</span>, <span class="hljs-number">3</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> post <span class="hljs-keyword">of</span> posts) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Fetch post <span class="hljs-subst">${post.id}</span>`</span>);
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> getWithRetry(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/post?id=<span class="hljs-subst">${post.id}</span>`</span>, <span class="hljs-number">3</span>);
    <span class="hljs-keyword">if</span> (content.content.includes(<span class="hljs-string">'async/await hell'</span>)) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Correct answer: <span class="hljs-subst">${post.id}</span>`</span>);
      <span class="hljs-keyword">break</span>;
    }
  }
}

run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));

<span class="hljs-comment">// This makes every 2nd `fetch()` fail</span>
<span class="hljs-keyword">const</span> _fetch = fetch;
<span class="hljs-keyword">let</span> calls = <span class="hljs-number">0</span>;
(<span class="hljs-built_in">window</span> || global).fetch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hard-coded fetch() error'</span>);
  <span class="hljs-keyword">return</span> (++calls % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-built_in">Promise</span>.reject(err) : _fetch(url);
}
</code></pre>

        </div>
        <div class="chapter">
          <h1 id="promises-from-the-ground-up">Promises From The Ground Up</h1>
<p>Async/await is built on top of promises. Async functions return promises, and
<code>await</code> only pauses an async function when it operates on a promise.
In order to grok the internals of async/await, you need to understand how
promises work from base principles. JavaScript promises didn&#39;t become what they
are by accident, they were carefully designed to enable paradigms like
async/await.</p>
<p>In the ES6 spec, a <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-executor">promise is a class</a> whose
constructor takes an <code>executor</code> function. Instances of the Promise class have a
<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.then"><code>then()</code> function</a>. Promises in the ES6 spec have several other properties, but for now you can
ignore them. Below is a skeleton of a simplified <code>Promise</code> class.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.1</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
  <span class="hljs-comment">// `executor` takes 2 parameters, `resolve()` and `reject()`.</span>
  <span class="hljs-comment">// The executor function is responsible for calling `resolve()`</span>
  <span class="hljs-comment">// or `reject()` when the async operation succeeded or failed</span>
  <span class="hljs-keyword">constructor</span>(executor) {}

  <span class="hljs-comment">// `onFulfilled` is called if the promise is fulfilled, and</span>
  <span class="hljs-comment">// `onRejected` if the promise is rejected. For now, you can</span>
  <span class="hljs-comment">// think of 'fulfilled' and 'resolved' as the same thing.</span>
  then(onFulfilled, onRejected) {}
}
</code></pre>
<p>A promise is a state machine with 3 states:</p>
<ul>
<li>pending: the initial state, means that the underlying operation is in progress</li>
<li>fulfilled: the underlying operation succeeded and has an associated value</li>
<li>rejected: the underlying operation failed and has an associated error</li>
</ul>
<p>A promise that is not pending is called <em>settled</em>. In other words, a settled
promise is either fulfilled or rejected. Once a promise is settled,
it <strong>cannot</strong> change state.
For example, the below promise will remain fulfilled despite the <code>reject()</code> call.
Once you&#39;ve called <code>resolve()</code> or <code>reject()</code> once, calling <code>resolve()</code> or <code>reject()</code>
is a no-op. This detail is pivotal for async/await, because how would <code>await</code> work
if a promise changed state from &#39;FULFILLED&#39; to &#39;REJECTED&#39; after an async function was done?</p>
<div class="example-header-wrap"><div class="example-header">Example 2.2</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  resolve(<span class="hljs-string">'foo'</span>);
  <span class="hljs-comment">// The below `reject()` is a no-op. A fulfilled promise stays</span>
  <span class="hljs-comment">// fulfilled with the same value forever.</span>
  reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'bar'</span>));
});
</code></pre>
<p>Below is a diagram showing the promise state machine.</p>
<svg xmlns="http://www.w3.org/2000/svg" width="600" height="390" viewbox="0 0 400 260">
  <line x1="100" y1="150" x2="300" y2="80" style="stroke:#000;stroke-width:5" />
  <line x1="100" y1="150" x2="300" y2="220" style="stroke:#000;stroke-width:5" />

  <line x1="245" y1="100" x2="220" y2="94" style="stroke:#000;stroke-width:5" />
  <line x1="245" y1="100" x2="232" y2="119" style="stroke:#000;stroke-width:5" />

  <line x1="245" y1="200" x2="230" y2="180" style="stroke:#000;stroke-width:5" />
  <line x1="245" y1="200" x2="220" y2="206" style="stroke:#000;stroke-width:5" />

  <!-- Pending -->
  <ellipse rx="75" ry="30" cx="100" cy="150" fill="#000"/>
  <ellipse rx="72" ry="27" cx="100" cy="150" fill="#fff"/>
  <text x="49" y="158" font-family="Roboto" font-size="24">
    PENDING
  </text>

  <!-- Fulfilled -->
  <ellipse rx="75" ry="30" cx="300" cy="80" fill="#000"/>
  <ellipse rx="72" ry="27" cx="300" cy="80" fill="#fff"/>
  <text x="243" y="89" font-family="Roboto" font-size="24">
    FULFILLED
  </text>

  <!-- Rejected -->
  <ellipse rx="75" ry="30" cx="300" cy="220" fill="#000"/>
  <ellipse rx="72" ry="27" cx="300" cy="220" fill="#fff"/>
  <text x="245" y="228" font-family="Roboto" font-size="24">
    REJECTED
  </text>

  <!-- Settled -->
  <line x1="200" y1="250" x2="200" y2="50" style="stroke:#f00;stroke-width:5" />
  <text x="250" y="30" font-family="Roboto" font-size="24" fill="red">
    SETTLED
  </text>
</svg>

<p>With this in mind, below is a first draft of a promise constructor that implements
the state transitions. Note that the property names <code>state</code>, <code>resolve</code>,
<code>reject</code>, and <code>value</code> used below are non-standard. Actual ES6 promises do <strong>not</strong>
expose these properties publicly, so don&#39;t try to use <code>p.value</code> or <code>p.resolve()</code>
with a native JavaScript promise.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.4</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
  <span class="hljs-keyword">constructor</span>(executor) {
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'PENDING'</span>;
    <span class="hljs-keyword">this</span>.chained = []; <span class="hljs-comment">// Not used yet</span>
    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Reject if the executor throws a sync error</span>
      executor(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-keyword">this</span>.resolve(v), err =&gt; <span class="hljs-keyword">this</span>.reject(err));
    } <span class="hljs-keyword">catch</span> (err) { <span class="hljs-keyword">this</span>.reject(err); }
  }
  <span class="hljs-comment">// Define `resolve()` and `reject()` to change the promise state</span>
  resolve(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'FULFILLED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
  }
  reject(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'REJECTED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
  }
}
</code></pre>
<p>The promise constructor manages the promise&#39;s state and calls the executor
function. You also need to implement the <code>then()</code> function that
let clients define handlers that run when a promise is settled. The <code>then()</code>
function takes 2 function parameters, <code>onFulfilled()</code> and <code>onRejected()</code>.
A promise must call the <code>onFulfilled()</code> callback if the promise is fulfilled,
and <code>onRejected()</code> if the promise is rejected.</p>
<p>For now, <code>then()</code> is simple, it adds <code>onFulfilled()</code> and
<code>onRejected()</code> to an array <code>chained</code>. Then, <code>resolve()</code> and <code>reject()</code> will call
them when the promise is fulfilled or rejected. If the promise is already
settled, the <code>then()</code> function will queue up <code>onFulfilled()</code> or <code>onRejected()</code>
to run on the next tick of the event loop using <code>setImmediate()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.5</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>{
  <span class="hljs-comment">// Constructor is the same as before, omitted for brevity</span>
  then(onFulfilled, onRejected) {
    <span class="hljs-keyword">const</span> { value, state } = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// If promise is already settled, enqueue the right handler</span>
    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'FULFILLED'</span>) <span class="hljs-keyword">return</span> setImmediate(onFulfilled, value);
    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'REJECTED'</span>) <span class="hljs-keyword">return</span> setImmediate(onRejected, value);
    <span class="hljs-comment">// Otherwise, track `onFulfilled` and `onRejected` for later</span>
    <span class="hljs-keyword">this</span>.chained.push({ onFulfilled, onRejected });
  }
  resolve(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'FULFILLED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
    <span class="hljs-comment">// Loop through the `chained` array and find all `onFulfilled()`</span>
    <span class="hljs-comment">// functions. Remember that `.then(null, onRejected)` is valid.</span>
    <span class="hljs-keyword">this</span>.chained.
      filter(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span>).
      <span class="hljs-comment">// The ES6 spec section 25.4 says `onFulfilled` and</span>
      <span class="hljs-comment">// `onRejected` must be called on a separate event loop tick</span>
      forEach(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> setImmediate(onFulfilled, value));
  }
  reject(value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'REJECTED'</span>;
    <span class="hljs-keyword">this</span>.value = value;
    <span class="hljs-keyword">this</span>.chained.
      filter(<span class="hljs-function">(<span class="hljs-params">{ onRejected }</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span>).
      forEach(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> setImmediate(onFulfilled, value));
  }
}
</code></pre>
<p>This <code>Promise</code> class, while simple, represents most of the work necessary
to integrate with async/await. The <code>await</code> keyword doesn&#39;t explicitly check
if the value it operates on is <code>instanceof Promise</code>, it only checks for the
presence of a <code>then()</code> function. In general, any object that has a <code>then()</code>
function is called a <em>thenable</em> in JavaScript. Below is an example of using the
custom <code>Promise</code> class with async/await.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.6</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Works, even though this is a custom `Promise` class. All you</span>
  <span class="hljs-comment">// need is a `then()` function to integrate with `await`.</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">'Hello'</span>), <span class="hljs-number">50</span>);
  });
  assert.equal(res, <span class="hljs-string">'Hello'</span>);
}
</code></pre>
<h2 id="promise-chaining">Promise Chaining</h2>
<p>One key feature that the promise implementation thus far does not support is
promise chaining. Promise chaining is a common pattern for keeping async code
flat, although it has become far less useful now that generators and async/await
have widespread support. Here&#39;s how the <code>getWikipediaHeaders()</code> function
from the introduction looks with promise chaining:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.7</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWikipediaHeaders</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> stat(<span class="hljs-string">'./headers.txt'</span>).
    then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// If you return a promise from `onFulfilled()`, the next</span>
        <span class="hljs-comment">// `then()` call's `onFulfilled()` will get called when</span>
        <span class="hljs-comment">// the returned promise is fulfilled...</span>
        <span class="hljs-keyword">return</span> get({ <span class="hljs-attr">host</span>: <span class="hljs-string">'www.wikipedia.org'</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">80</span> });
      }
      <span class="hljs-keyword">return</span> res;
    }).
    then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
      <span class="hljs-comment">// So whether the above `onFulfilled()` returns a primitive or a</span>
      <span class="hljs-comment">// promise, this `onFulfilled()` gets the headers object</span>
      <span class="hljs-keyword">return</span> writeFile(<span class="hljs-string">'./headers.txt'</span>, <span class="hljs-built_in">JSON</span>.stringify(res.headers));
    }).
    then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Great success!'</span>)).
    catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.err(err.stack));
}
</code></pre>
<p>While async/await is a superior pattern, promise chaining is still useful,
and still necessary to complete a robust promise implementation. In order
to implement promise chaining, you need to make 3 changes to the promise
implementation from example 2.5:</p>
<ol>
<li>The <code>then()</code> function needs to return a promise. The promise returned from <code>then()</code> should be resolved with the value returned from <code>onFulfilled()</code></li>
<li>The <code>resolve()</code> function needs to check if <code>value</code> is a thenable, and, if so, transition to fulfilled or rejected only when <code>value</code> transitions to fulfilled or rejected.</li>
<li>If <code>resolve()</code> is called with a thenable, the promise needs to stay &#39;PENDING&#39;, but future calls to <code>resolve()</code> and <code>reject()</code> must be ignored.</li>
</ol>
<p>The first change, improving the <code>then()</code> function, is shown below. There are
two other changes: <code>onFulfilled()</code> and <code>onRejected()</code> now have default
values, and are wrapped in a try/catch.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.8</div></div>

<pre><code class="lang-javascript">then(_onFulfilled, _onRejected) {
  <span class="hljs-comment">// `onFulfilled` is a no-op by default...</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> _onFulfilled !== <span class="hljs-string">'function'</span>) _onFulfilled = (<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v);
  <span class="hljs-comment">// and `onRejected` just rethrows the error by default</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> _onRejected !== <span class="hljs-string">'function'</span>) {
    _onRejected = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { <span class="hljs-keyword">throw</span> err; };
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// Wrap `onFulfilled` and `onRejected` for two reasons:</span>
    <span class="hljs-comment">// consistent async and `try/catch`</span>
    <span class="hljs-keyword">const</span> onFulfilled = <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        resolve(_onFulfilled(res));
      } <span class="hljs-keyword">catch</span> (err) { reject(err); }
    });
    <span class="hljs-keyword">const</span> onRejected = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Note this is `resolve()`, **not** `reject()`. The `then()`</span>
        <span class="hljs-comment">// promise will be fulfilled if `onRejected` doesn't rethrow</span>
        resolve(_onRejected(err));
      } <span class="hljs-keyword">catch</span> (err) { reject(err); }
    });

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'FULFILLED'</span>) <span class="hljs-keyword">return</span> onFulfilled(<span class="hljs-keyword">this</span>.value);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'REJECTED'</span>) <span class="hljs-keyword">return</span> onRejected(<span class="hljs-keyword">this</span>.value);
    <span class="hljs-keyword">this</span>.chained.push({ onFulfilled, onRejected });
  });
}
</code></pre>
<p>Now <code>then()</code> returns a promise. However, there&#39;s still work to be done: if
<code>onFulfilled()</code> returns a promise, <code>resolve()</code> needs to be able to handle it.
In order to support this, the <code>resolve()</code> function will need to use <code>then()</code>
in a two-step recursive dance. Below is the expanded <code>resolve()</code> function
that shows the 2nd necessary change.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.9</div></div>

<pre><code class="lang-javascript">resolve(value) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state !== <span class="hljs-string">'PENDING'</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (value === <span class="hljs-keyword">this</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.reject(<span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Can't resolve promise with itself`</span>));
  }
  <span class="hljs-comment">// Is `value` a thenable? If so, fulfill/reject this promise when</span>
  <span class="hljs-comment">// `value` fulfills or rejects. The Promises/A+ spec calls this</span>
  <span class="hljs-comment">// process "assimilating" the other promise (resistance is futile).</span>
  <span class="hljs-keyword">const</span> then = <span class="hljs-keyword">this</span>._getThenProperty(value);
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> then.call(value, v =&gt; <span class="hljs-keyword">this</span>.resolve(v),
        err =&gt; <span class="hljs-keyword">this</span>.reject(err));
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">return</span> reject(error);
    }
  }

  <span class="hljs-comment">// If `value` is **not** a thenable, transition to fulfilled</span>
  <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'FULFILLED'</span>;
  <span class="hljs-keyword">this</span>.value = value;
  <span class="hljs-keyword">this</span>.chained.
    forEach(<span class="hljs-function">(<span class="hljs-params">{ onFulfilled }</span>) =&gt;</span> setImmediate(onFulfilled, value));
}
<span class="hljs-comment">// Helper to wrap getting the `then()` property because the Promises/A+</span>
<span class="hljs-comment">// spec has 2 tricky details: you can only access the `then` property</span>
<span class="hljs-comment">// once, and if getting `value.then` throws the promise should reject</span>
_getThenProperty(value) {
  <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (![<span class="hljs-string">'object'</span>, <span class="hljs-string">'function'</span>].includes(<span class="hljs-keyword">typeof</span> value)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> value.then;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Unlikely edge case, Promises/A+ section 2.3.3.2 enforces this</span>
    <span class="hljs-keyword">this</span>.reject(error);
  }
}
</code></pre>
<p>Finally, the third change, ensuring that a promise doesn&#39;t change state
once <code>resolve()</code> is called with a thenable, requires changes to both
<code>resolve()</code> and the promise constructor. The motivation for this change
is to ensure that <code>p2</code> in the below example is fulfilled, <strong>not</strong> rejected.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.10</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">50</span>));
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
  resolve(p1);
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); <span class="hljs-comment">// Ignored because `resolve()` was called</span>
});
</code></pre>
<p>One way to achieve this is to create a helper function that wraps
<code>this.resolve()</code> and <code>this.reject()</code> that ensures <code>resolve()</code> and <code>reject()</code>
can only be called once.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.11</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// After you call `resolve()` with a promise, extra `resolve()` and</span>
<span class="hljs-comment">// `reject()` calls will be ignored despite the 'PENDING' state</span>
_wrapResolveReject() {
  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;
    called = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.resolve(v);
  };
  <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;
    called = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.reject(err);
  };
  <span class="hljs-keyword">return</span> { resolve, reject };
}
</code></pre>
<p>Once you have this <code>_wrapResolveReject()</code> helper, you need to use it in
<code>resolve()</code>:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.12</div></div>

<pre><code class="lang-javascript">resolve(value) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) {
    <span class="hljs-comment">// If `then()` calls `resolve()` with a 'PENDING' promise and then</span>
    <span class="hljs-comment">// throws, the `then()` promise will be fulfilled like example 2.10</span>
    <span class="hljs-keyword">const</span> { resolve, reject } = <span class="hljs-keyword">this</span>._wrapResolveReject();
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> then.call(value, resolve, reject);
    } <span class="hljs-keyword">catch</span> (error) { <span class="hljs-keyword">return</span> reject(error); }
  }
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<div class="page-break"></div>

<p>Also, you need to use <code>_wrapResolveReject()</code> in the constructor itself:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.13</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">constructor</span>(executor) { <span class="hljs-comment">// Beginning omitted for brevity</span>
  <span class="hljs-comment">// This makes the promise class handle example 2.10 correctly...</span>
  <span class="hljs-keyword">const</span> { resolve, reject } = <span class="hljs-keyword">this</span>._wrapResolveReject();
  <span class="hljs-keyword">try</span> {
    executor(resolve, reject);
    <span class="hljs-comment">// because if `executor` calls `resolve()` and then throws,</span>
    <span class="hljs-comment">// the below `reject()` is a no-op</span>
  } <span class="hljs-keyword">catch</span> (err) { reject(err); }
}
</code></pre>
<p>With all these changes, the complete promise implementation, which you can
find at <a href="http://bit.ly/simple-promise">bit.ly/simple-promise</a>, now passes
all 872 test cases in the <a href="https://promisesaplus.com/">Promises/A+ spec</a>.
The Promises/A+ spec is <a href="https://promisesaplus.com/implementations#the-ecmascript-specification">a subset of the ES6 promise spec</a> that focuses on <code>then()</code> and the promise constructor.</p>
<h2 id="-catch-and-other-helpers"><code>catch()</code> and Other Helpers</h2>
<p>The ES6 promise spec is a superset of the Promises/A+ spec that adds several
convenient helper methods on top of the <code>then()</code> function. The most commonly
used helper is the <code>catch()</code> function. Like the synchronous <code>catch</code> keyword, the
<code>catch()</code> function typically appears at the end of a promise chain to handle
any errors that occurred.</p>
<p>The <code>catch()</code> function may sound complex, but it is just a thin layer of syntactic
sugar on top of <code>then()</code>. The <code>catch()</code> is so sticky because
the name <code>catch()</code> is a powerful metaphor for explaining what this helper is used for.
Below is the full implementation of <code>catch()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.14</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">catch</span>(onRejected) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected);
}
</code></pre>
<p>Why does this work? Recall from example 2.8 that <code>then()</code> has a default <code>onRejected()</code>
argument that rethrows the error. So when a promise is rejected, subsequent <code>then()</code>
calls that only specify an <code>onFulfilled()</code> handler are skipped.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.15</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> originalError = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> reject(originalError)).
  then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This will not print'</span>)).
  then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Nor will this'</span>)).
  <span class="hljs-comment">// The `onFulfilled()` handlers above get skipped. Each of the</span>
  <span class="hljs-comment">// `then()` promises above reject with the original error</span>
  <span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> assert.ok(err === originalError));
</code></pre>
<p>There are several other helpers in the ES6 promise spec. The <code>Promise.resolve()</code>
and <code>Promise.reject()</code> helpers are both commonly used for testing and examples,
as well as to convert a thenable into a fully fledged promise.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.16</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// Yes, this is actually a thenable. When it comes to promises, the</span>
<span class="hljs-comment">// letter of the law overrules the spirit of the law.</span>
<span class="hljs-keyword">const</span> thenable = { <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); } };
<span class="hljs-comment">// But `thenable` doesn't have `catch()`, so use `Promise.resolve()`</span>
<span class="hljs-comment">// to convert it to a promise and use `catch()`</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(thenable).
  catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err.message)); <span class="hljs-comment">// Prints "Oops!"</span>
</code></pre>
<p>Below is the implementation of <code>resolve()</code> and <code>reject()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.17</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">static</span> resolve(v) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(v));
}
<span class="hljs-keyword">static</span> reject(err) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(err));
}
</code></pre>
<p>The <code>Promise.all()</code> function is another important helper, because it lets you execute multiple promises in
parallel and <code>await</code> on the result. The below code will run two instances of
the <code>run()</code> function in parallel, and pause execution until they&#39;re both done.</p>
<div class="example-header-wrap"><div class="example-header">Example 2.18</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">50</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'run(): running'</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">50</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'run(): done'</span>);
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start running'</span>);
<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([run(), run()]);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done'</span>);
<span class="hljs-comment">// Start running</span>
<span class="hljs-comment">// run(): running</span>
<span class="hljs-comment">// run(): running</span>
<span class="hljs-comment">// run(): done</span>
<span class="hljs-comment">// run(): done</span>
<span class="hljs-comment">// Done</span>
</code></pre>
<p><code>Promise.all()</code> is the preferred mechanism for executing async functions in parallel.
To execute async functions in series, you would use a <code>for</code> loop and <code>await</code> on
each function call.</p>
<p><code>Promise.all()</code> is just a convenient wrapper around calling <code>then()</code> on an array
of promises and waiting for the result. Below is a simplified implementation of
<code>Promise.all()</code>:</p>
<div class="example-header-wrap"><div class="example-header">Example 2.19</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">static</span> all(arr) {
  <span class="hljs-keyword">let</span> remaining = arr.length;
  <span class="hljs-keyword">if</span> (remaining === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve([]);
  <span class="hljs-comment">// `result` stores the value that each promise is fulfilled with</span>
  <span class="hljs-keyword">let</span> result = [];
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">// Loop through every promise in the array and call `then()`. If</span>
    <span class="hljs-comment">// the promise fulfills, store the fulfilled value in `result`.</span>
    <span class="hljs-comment">// If any promise rejects, the `all()` promise rejects immediately.</span>
    arr.forEach(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> p.then(
      <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
        result[i] = res;
        --remaining || resolve(result);
      },
      err =&gt; reject(err)));
  });
}
</code></pre>
<p>There is one more helper function defined in the ES6 spec, <code>Promise.race()</code>,
that will be an exercise. Other than <code>race()</code> and some minor details like
support for subclassing, the promise implementation in this chapter is
compliant with the ES6 spec. In the next chapter, you&#39;ll use your
understanding of promises to monkey-patch async/await and figure out what&#39;s
happening under the hood.</p>
<p>The key takeaways from this journey
of building a promise library from scratch are:</p>
<ul>
<li>A promise can be in one of 3 states: pending, fulfilled, or rejected. It can also be locked in to match the state of another promise if you call <code>resolve(promise)</code>.</li>
<li>Once a promise is settled, it stays settled with the same value forever</li>
<li>The <code>then()</code> function and the promise constructor are the basis for all other promise functions. The <code>catch()</code>, <code>all()</code>, <code>resolve()</code>, and <code>reject()</code> helpers are all syntactic sugar on top of <code>then()</code> and the constructor.</li>
</ul>
<p>But before you start tinkering with the internals of async/await, here&#39;s 2 exercises
to expand your understanding of promises.</p>
<div class="page-break"></div>

<h1 id="exercise-1-promise-chains-in-action">Exercise 1: Promise Chains in Action</h1>
<p>The purpose of this exercise is to get comfortable with using promise chaining.
While promise chaining is less useful now that async/await exists, promise
chaining is a useful complement to async/await in much the same way that
<code>forEach()</code> and <code>filter()</code> are useful for chaining array transformations.</p>
<p>Using the same endpoints as Exercise 1.1, which are explained below, find the blog
post entitled &quot;Unhandled Promise Rejections in Node.js&quot;, load its content, and find the number of times the phrase &quot;async/await&quot; appears in the <code>content</code>.</p>
<p>Below are the API endpoints. The API endpoints are hosted on Google Cloud Functions
at <code>https://us-central1-mastering-async-await.cloudfunctions.net</code></p>
<ul>
<li><code>/posts</code> gets a list of blog posts. Below is an example post:</li>
</ul>
<pre><code>{ <span class="hljs-string">"src"</span>:<span class="hljs-string">"./lib/posts/20160304_circle_ci.md"</span>,
  <span class="hljs-string">"title"</span>:<span class="hljs-string">"Setting Up Circle CI With Node.js"</span>,
  <span class="hljs-string">"date"</span>:<span class="hljs-string">"2016-03-04T00:00:00.000Z"</span>,
  <span class="hljs-string">"tags"</span>:[<span class="hljs-string">"NodeJS"</span>],
  <span class="hljs-string">"id"</span>:<span class="hljs-number">51</span> }
</code></pre><ul>
<li><code>/post?id=${id}</code> gets the markdown content of a blog post by its <code>id</code> property. The above blog post has <code>id</code> = 0, so you can get its content from this endpoint: <a href="https://us-central1-mastering-async-await.cloudfunctions.net/post?id=0"><code>https://us-central1-mastering-async-await.cloudfunctions.net/post?id=0</code></a>. Try opening this URL in your browser, the output looks like this:</li>
</ul>
<pre><code>{<span class="hljs-string">"content"</span>:<span class="hljs-string">"*This post was featured as a guest blog post..."</span>}
</code></pre><p>Below is the starter code. You may copy this code and run it in Node.js using <a href="https://www.npmjs.com/package/node-fetch">the <code>node-fetch</code> npm module</a>, or you may complete this exercise in your browser
on CodePen at <a href="http://bit.ly/async-await-exercise-21"><code>http://bit.ly/async-await-exercise-21</code></a></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> root = <span class="hljs-string">'https://'</span> +
  <span class="hljs-string">'us-central1-mastering-async-await.cloudfunctions.net'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Example of using `fetch()` API</span>
  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`<span class="hljs-subst">${root}</span>/posts`</span>).
    then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json()).
    then(<span class="hljs-function"><span class="hljs-params">posts</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(posts[<span class="hljs-number">0</span>]));
}
run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));
</code></pre>
<div class="page-break"></div>

<h1 id="exercise-2-promise-race-">Exercise 2: <code>Promise.race()</code></h1>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ES6 promise spec</a> has one more helper method that this book hasn&#39;t covered yet:
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race()</code></a>.
Like <code>Promise.all()</code>, <code>Promise.race()</code> takes in an array of promises, but
<code>Promise.race()</code> returns a promise that resolves or rejects to the same value
that the first promise to settle resolves or rejects to. For example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">50</span>));
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">2</span>), <span class="hljs-number">250</span>));
<span class="hljs-comment">// Prints "1", because `p1` resolves first</span>
<span class="hljs-built_in">Promise</span>.race([p1, p2]).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res));
</code></pre>
<p>Implement a function <code>race()</code>, that, given an array of promises, returns a
promise that resolves or rejects as soon as one of the promises in the array
settles, with the same value.</p>
<p>Hint: remember, once a promise is settled, calling <code>resolve()</code> or <code>reject()</code> is a
no-op.</p>
<p>Below is the starter code. You may copy this code and complete this exercise in
Node.js, or you may complete it in your browser
on CodePen at <a href="http://bit.ly/async-await-exercise-22"><code>http://bit.ly/async-await-exercise-22</code></a>.</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">race</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Implement this function'</span>));
}

<span class="hljs-comment">// The below are tests to help you check your `race()` implementation</span>
test1().then(test2).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done!'</span>)).
  catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">10</span>));
  <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">2</span>), <span class="hljs-number">100</span>));
  <span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> { <span class="hljs-keyword">if</span> (v !== <span class="hljs-number">1</span>) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'test1 failed!'</span>); };
  <span class="hljs-keyword">return</span> race([p1, p2]).then(f);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected error'</span>);
  <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">100</span>));
  <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">2</span>), <span class="hljs-number">100</span>));
  <span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(error));
  <span class="hljs-keyword">return</span> race([p1, p2, p3]).then(
    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'test2: `race()` promise must reject'</span>); },
    e =&gt; { <span class="hljs-keyword">if</span> (e !== error) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'test2: wrong error'</span>); });
}
</code></pre>

        </div>
        <div class="chapter">
          <h1 id="async-await-internals">Async/Await Internals</h1>
<p>Promises are the fundamental tool for integrating with async/await. Now
that you&#39;ve seen how promises work from the ground up, it&#39;s time to go from
the micro to the macro and see what happens when you <code>await</code> on a promise.
Even though async functions are flat like synchronous functions, they&#39;re
as asynchronous as the most callback-laden banana code under the hood.</p>
<p>As you might have already guessed, <code>await</code> makes JavaScript call <code>then()</code>
under the hood.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.1</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> p = {
  <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-params">onFulfilled</span> =&gt;</span> {
    <span class="hljs-comment">// Prints "then(): function () { [native code] }"</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'then():'</span>, onFulfilled.toString());
    <span class="hljs-comment">// Only one entry in the stack:</span>
    <span class="hljs-comment">// Error</span>
    <span class="hljs-comment">//     at Object.then (/examples/chapter3.test.js:8:21)</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>().stack);
    onFulfilled(<span class="hljs-string">'Hello, World!'</span>);
  }
};

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> p); <span class="hljs-comment">// Prints "Hello, World!"</span>
</code></pre>
<p>The <code>await</code> keyword causes JavaScript to <em>pause</em> execution until the next
iteration of the event loop. In the below code, the <code>console.log()</code> after
the <code>await</code> runs <strong>after</strong> the <code>++currentId</code> code, even though the increment
is in a callback. The <code>await</code> keyword causes the async function to pause
and then resume later.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.2</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> startId = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> currentId = <span class="hljs-number">0</span>;
process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ++currentId);
<span class="hljs-keyword">const</span> p = {
  <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-params">onFulfilled</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'then():'</span>, currentId - startId); <span class="hljs-comment">// "then(): 1"</span>
    onFulfilled(<span class="hljs-string">'Hello, World!'</span>);
  }
};

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Before:'</span>, currentId - startId); <span class="hljs-comment">// "Before: 0"</span>
<span class="hljs-keyword">await</span> p;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'After:'</span>, currentId - startId); <span class="hljs-comment">// "After: 1"</span>
</code></pre>
<p>Notice that the <code>then()</code> function runs on the next tick, even though it is
fully synchronous. This means that <code>await</code> always pauses execution until at
least the next tick, even if the thenable is not async.The same thing happens
when the awaited promise is rejected. If you call
<code>onRejected(err)</code>, the <code>await</code> keyword throws <code>err</code> in your function body.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.3</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> startId = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> currentId = <span class="hljs-number">0</span>;
process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ++currentId);
<span class="hljs-keyword">const</span> p = {
  <span class="hljs-attr">then</span>: <span class="hljs-function">(<span class="hljs-params">onFulfilled, onRejected</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'then():'</span>, currentId - startId); <span class="hljs-comment">// "then(): 1</span>
    <span class="hljs-keyword">return</span> onRejected(<span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
  }
};

<span class="hljs-keyword">try</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Before:'</span>, currentId - startId); <span class="hljs-comment">// "Before: 0"</span>
  <span class="hljs-keyword">await</span> p;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This does not print'</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'After:'</span>, currentId - startId); <span class="hljs-comment">// "After: 1"</span>
}
</code></pre>
<h2 id="-await-vs-return-"><code>await</code> vs <code>return</code></h2>
<p>Recall that <code>return</code> in an async function resolves the promise that the async
function returns. This means you can <code>return</code> a promise. What&#39;s the difference
between <code>await</code> and <code>return</code>? The obvious answer is that, when you <code>await</code> on
a promise, JavaScript pauses execution of the async function and resumes later,
but when you <code>return</code> a promise, JavaScript finishes executing the async
function. JavaScript doesn&#39;t &quot;resume&quot; executing the function after you <code>return</code>.</p>
<p>The obvious answer is correct, but has some non-obvious implications
that tease out how <code>await</code> works. If you wrap <code>await p</code> in a <code>try/catch</code>
and <code>p</code> is rejected, you can catch the error. What happens if you
instead <code>return p</code>?</p>
<div class="example-header-wrap"><div class="example-header">Example 3.4</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
  } <span class="hljs-keyword">catch</span> (error) { <span class="hljs-keyword">return</span> <span class="hljs-string">'ok'</span>; }
}
<span class="hljs-comment">// Prints "Oops!"</span>
test().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v), err =&gt; <span class="hljs-built_in">console</span>.log(err.message));
</code></pre>
<p>Notice that <code>try/catch</code> does <strong>not</strong> catch the rejected promise that you
returned. Why does only <code>await</code> give you a catchable error when the promise
is rejected? Because <code>await</code> throws the error when it <em>resumes</em> execution.
When you <code>return</code> a promise, JavaScript stops executing your async function
body and kicks off the <code>resolve()</code> process on the async function promise.</p>
<p>On the other hand, when you <code>await</code> on a promise, JavaScript pauses executing
your async function and resumes once the promise is settled. When JavaScript
resumes your async function after <code>await</code>, it throws an error if the awaited
promise rejected. Below is a flow chart showing what happens when you await
on a promise.</p>
<p><img src="../images/flow.png"></p>
<p>On the other hand, when you <code>return</code> a promise from an async function, your
promise goes into the JavaScript runtime and never goes back into your code,
so <code>try/catch</code> won&#39;t handle the error in example 3.4. Below are a couple
alternatives that <code>catch</code> the error: example 3.5 assigns <code>await p</code> to a
variable <code>v</code> and then returns the variable, and example 3.6 uses <code>return await</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.5</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
    <span class="hljs-keyword">return</span> v;
  } <span class="hljs-keyword">catch</span> (error) { <span class="hljs-keyword">return</span> <span class="hljs-string">'ok'</span>; }
}
<span class="hljs-comment">// Prints "ok"</span>
test().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v), err =&gt; <span class="hljs-built_in">console</span>.log(err.message));
</code></pre>
<div class="example-header-wrap"><div class="example-header">Example 3.6</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>));
  } <span class="hljs-keyword">catch</span> (error) { <span class="hljs-keyword">return</span> <span class="hljs-string">'ok'</span>; }
}
<span class="hljs-comment">// Prints "ok"</span>
test().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v), err =&gt; <span class="hljs-built_in">console</span>.log(err.message));
</code></pre>
<p>Both approaches work, but example 3.5 is simpler and less confusing. Seeing
<code>return await</code> is a head-scratcher for engineers that aren&#39;t JavaScript experts,
and that&#39;s antithetical to the goal of making asynchronous code easy for
average developers.</p>
<h2 id="concurrency">Concurrency</h2>
<p>So far, you&#39;ve seen that <code>await p</code> makes JavaScript pause your async function,
call <code>p.then()</code>, and resume once the promise is settled. What does this mean
for running multiple async functions in parallel, especially given that
JavaScript is single threaded?</p>
<p>The &quot;JavaScript is single threaded&quot; concept means that, when a normal JavaScript
function is running, no other JavaScript can run. For example, the below code
will never print anything. In other languages, a construct like <code>setImmediate()</code>
may run logic in a separate thread and print even while an infinite loop is
spinning, but JavaScript does not allow that.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.7</div></div>

<pre><code class="lang-javascript">setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>));
<span class="hljs-comment">// This loop will spin forever, and so you'll never get back into</span>
<span class="hljs-comment">// the event loop and the above `console.log()` will never run.</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}
</code></pre>
<p>JavaScript functions are like the <a href="https://www.britannica.com/science/Pauli-exclusion-principle">Pauli Exclusion Principle</a> in physics:
no two normal JavaScript functions can be running in the same memory space at
the same time. Closures (callbacks) are separate functions, so in the below
example, <code>foo()</code>, <code>bar()</code>, and <code>baz()</code> all run separately.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.8</div></div>

<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// When `foo()` is done, `bar()` will run later but still have</span>
  <span class="hljs-comment">// access to `x`</span>
  setImmediate(bar);
  <span class="hljs-comment">// Stop running `foo()` until `baz()` is done</span>
  baz();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
    ++x;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>) </span>{
    ++x;
  }
}
</code></pre>
<p>Async functions follow the same rule: no two functions can be running at the
same time. But, any number of async functions can be <em>paused</em> at the same time
as long as you don&#39;t run out of memory, and other functions can run when an
async function is paused.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.9</div></div>

<pre><code class="lang-javascript">run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This will print, because `run()` is paused when you `await`</span>
  setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>));
  <span class="hljs-comment">// Each iteration of the loop pauses the function</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve)); }
}
</code></pre>
<p>This makes async functions useful for breaking up long-running synchronous
functions.
For example, suppose you want to run two functions in
parallel that each compute a large <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a>. Without async/await,
you&#39;d need tricky recursion. Async/await makes this
task trivial.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.10</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([fibonacci(<span class="hljs-number">50000</span>), fibonacci(<span class="hljs-number">50000</span>)]);
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> [prev2, prev1, cur] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) {
    <span class="hljs-comment">// Pause this `fibonacci()` call, let the other call make progress</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve));
    <span class="hljs-comment">// "Fib: 10000"</span>
    <span class="hljs-comment">// "Fib: 10000"</span>
    <span class="hljs-comment">// "Fib: 20000" ...</span>
    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">10000</span> === <span class="hljs-number">0</span>) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Fib:'</span>, i);
    cur = prev1 + prev2;
    prev2 = prev1;
    prev1 = cur;
  }
  <span class="hljs-keyword">return</span> cur;
}
</code></pre>
<p>This example is simple but contrived. A more realistic example would be
an Express API endpoint that runs a potentially expensive algorithm like
<a href="http://thecodebarbarian.com/single-link-clustering-with-node-js.html">clustering</a>.
I have used this pattern in a production Express API to run an
<code>O(n^5)</code> clustering algorithm in a route without blocking other routes.</p>
<p>The key takeaway here is that an async function will run with no interruptions
unless you pause it with <code>await</code> or exit the function with <code>return</code> or <code>throw</code>.
JavaScript is still single threaded in the conventional sense, so two async
functions can&#39;t be running at the same time, but you can pause your async
function using <code>await</code> to give the event loop and other functions a chance to
run.</p>
<h2 id="async-await-vs-generators">Async/Await vs Generators</h2>
<p>Async/await has a lot in common with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">generators</a>, a feature that JavaScript introduced in the 2015 edition of the
language spec. Like async functions, generator functions can be paused and
later resumed. There
are two major differences between generator functions and async functions:</p>
<ol>
<li>The keyword you use to pause a generator function is <code>yield</code>, not <code>await</code>.</li>
<li>When you pause a generator function, control goes back to your JavaScript code, rather than the JS interpreter. You resume the generator function by calling <code>next()</code> on a generator object.</li>
</ol>
<p>The below example demonstrates using <code>yield</code> to pause the generator and <code>next()</code> to resume it.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.11</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// The `function*` syntax makes this function a generator function</span>
<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Step 1'</span>);
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Step 2'</span>);
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done'</span>);
};

<span class="hljs-comment">// The return value of a generator function is a generator object.</span>
<span class="hljs-comment">// The generator function doesn't start until you call `next()`.</span>
<span class="hljs-keyword">const</span> generatorObject = generatorFunction();

<span class="hljs-keyword">let</span> yielded = generatorObject.next(); <span class="hljs-comment">// Prints "Step 1"</span>
<span class="hljs-built_in">console</span>.log(yielded.value); <span class="hljs-comment">// Prints "1"</span>
yielded = generatorObject.next(); <span class="hljs-comment">// Prints "Step 2"</span>
<span class="hljs-built_in">console</span>.log(yielded.value); <span class="hljs-comment">// Prints "2"</span>
generatorObject.next(); <span class="hljs-comment">// Prints "Done"</span>
</code></pre>
<p>With the help of a library, generators support a pattern virtually identical
to async/await. The most popular generator concurrency library is <a href="https://www.npmjs.com/package/co">co</a>. Here&#39;s example 1.1 with co instead of async/await.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.12</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-comment">// `co.wrap()` converts a generator into an async-like function</span>
<span class="hljs-keyword">const</span> runCo = co.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This function will print "Hello, World!" after 1 second.</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(), <span class="hljs-number">1000</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
});
<span class="hljs-comment">// In particular, wrapped functions return a promise</span>
runCo().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error.stack));
</code></pre>
<p>Co offers several neat features that async/await does not natively support. By
virtue of being a userland library, co can be more extensible.
For example, co can handle when you <code>yield</code> an array of promises or a
map of promises.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.13</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> runCo = co.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello'</span>);
  <span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'World'</span>);
  <span class="hljs-comment">// Co can convert arrays of promises and objects with promise</span>
  <span class="hljs-comment">// properties for you. With async/await, you'd have to use</span>
  <span class="hljs-comment">// `Promise.all()` on your own to `await` on an array of promises</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> [p1, p2]); <span class="hljs-comment">// [ 'Hello', 'World' ]</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">yield</span> { p1, p2 }); <span class="hljs-comment">// { p1: 'Hello', p2: 'World' }</span>
});
</code></pre>
<p>The flip-side of co&#39;s implicit promise conversion is that co throws an error if
you <code>yield</code> something that it can&#39;t convert to a promise.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.14</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> runCo = co.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 'TypeError: You may only yield a function, promise, generator,</span>
  <span class="hljs-comment">// array, or object but the following object was passed: "1"'</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
});
</code></pre>
<p>In practice, co treating <code>yield 1</code> as an error helps catch a lot of errors, but
also causes a lot of unnecessary errors. With async/await, <code>await 1</code> is
valid and evaluates to <code>1</code>, which is more robust.</p>
<p>Async/await has a few other advantages over co and generators. The biggest advantage
is that async/await is built-in to Node.js and modern browsers, so you don&#39;t
need an external library like co. Async/await also has cleaner stack traces.
Co stack traces often have a lot of <code>generator.next()</code> and <code>onFulfilled</code> lines
that obscure the actual error.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.15</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> runCo = co.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve));
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
});
<span class="hljs-comment">// Error: Oops!</span>
<span class="hljs-comment">//    at /test.js:3:9</span>
<span class="hljs-comment">//    at Generator.next (&lt;anonymous&gt;)</span>
<span class="hljs-comment">//    at onFulfilled (/node_modules/co/index.js:65:19)</span>
<span class="hljs-comment">//    at &lt;anonymous&gt;</span>
runCo().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error.stack));
</code></pre>
<p>The equivalent async/await stack trace has the function name and omits <code>generator.next()</code> and <code>onFulfilled</code>. Async/await&#39;s <code>onFulfilled</code>
runs in the JavaScript interpreter, not userland.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.16</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runAsync</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve));
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>);
}
<span class="hljs-comment">// Error: Oops!</span>
<span class="hljs-comment">//    at runAsync (/home/val/test.js:5:9)</span>
<span class="hljs-comment">//    at &lt;anonymous&gt;</span>
runAsync().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error.stack));
</code></pre>
<p>In general, async/await is the better paradigm because it is built in to
JavaScript, throws fewer unnecessary errors, and has most of the functionality
you need. Co has some neat syntactic sugar and works in older browsers, but
that is not enough to justify including an external library.</p>
<h2 id="core-principles">Core Principles</h2>
<p>So far, this chapter has covered the technical details of what it means for
an async function to be paused. What does all this mean for a developer looking
to use async/await for their application? Here&#39;s some core principles
to remember based on the behaviors this chapter covered.</p>
<h3 id="don-t-await-on-a-value-that-can-t-be-a-promise">Don&#39;t <code>await</code> on a value that can&#39;t be a promise</h3>
<p>Just because you can <code>await 1</code> doesn&#39;t mean you should. A lot of async/await
beginners abuse <code>await</code> and <code>await</code> on everything.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.17</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSubstr</span>(<span class="hljs-params">arr, str</span>) </span>{
  <span class="hljs-comment">// Don't do this! There's no reason for this function to be async</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-keyword">await</span> <span class="hljs-number">0</span>; i &lt; arr.length; ++i) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> arr[i].includes(str)) <span class="hljs-keyword">return</span> arr[i];
  }
}
</code></pre>
<p>In general, you should use <code>await</code> on a value you expect to be a promise.
There is no reason to <code>await</code> on a value that will never be a promise, and
it falsely implies that the value may be a promise. If a function can be
synchronous, it should be synchronous.</p>
<p>The only reason to make the <code>findSubstr()</code> function async would be to pause
execution and let other functions run like in example 3.10. This is only
potentially beneficial if <code>findSubstr()</code> runs on a massive array. In that case,
you should use <code>await new Promise(setImmediate)</code> in order to make sure all other
tasks have a chance to run.</p>
<p>Similarly, you must convert any value you want to <code>await</code> on into a promise.
For example, if you want to <code>await</code> on multiple promises in parallel you must
use <code>Promise.all()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.18</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);
  <span class="hljs-comment">// Won't work, `arr1` will be an array of promises</span>
  <span class="hljs-keyword">const</span> arr1 = <span class="hljs-keyword">await</span> [p1, p2];
  <span class="hljs-comment">// Works! `arr1` will equal `[1, 2]`</span>
  <span class="hljs-keyword">const</span> arr2 = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(p1, p2);
}
</code></pre>
<h3 id="prefer-using-return-with-a-non-promise">Prefer using <code>return</code> with a non-promise</h3>
<p>As demonstrated in example 3.4, you can <code>return</code> a promise from an async function,
but doing so has some nuances and corner cases. Instead of using a promise as
the resolved value, use <code>await</code> to resolve the value and then <code>return</code> the value. It is generally easier to use <code>await</code> and return the resolved value
than to explain the difference between <code>async</code> and <code>return</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.19</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Fine, but has some issues with `try/catch` as shown in example 3.4</span>
  <span class="hljs-keyword">return</span> asyncFunction();
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// More verbose, but less error prone. Use this method unless you do</span>
  <span class="hljs-comment">// not intend to handle `asyncFunction()` errors in this function.</span>
  <span class="hljs-keyword">const</span> ret = <span class="hljs-keyword">await</span> asyncFunction();
  <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<h3 id="use-loops-rather-than-array-helpers-like-foreach-and-map-with-await-">Use loops rather than array helpers like <code>forEach()</code> and <code>map()</code> with <code>await</code></h3>
<p>Because you can only <code>await</code> in an async function, async functions behave
differently than synchronous functions when it comes to functional array methods
like <code>forEach()</code>. For example, the below code throws a <code>SyntaxError</code> because
<code>await</code> is not in an async function.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.20</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);
  <span class="hljs-comment">// SyntaxError: Unexpected identifier</span>
  [p1, p2].forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> { <span class="hljs-keyword">await</span> p; });
}
</code></pre>
<p>You might think that all you need is an async arrow function. But that
does <strong>not</strong> pause <code>test()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.21</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);
  <span class="hljs-comment">// This sets off two async functions in parallel, but does **not**</span>
  <span class="hljs-comment">// pause `test()` because `await p` pauses the arrow function.</span>
  [p1, p2].forEach(<span class="hljs-keyword">async</span> (p) =&gt; { <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> p); });
  <span class="hljs-comment">// 'Done' will print **before** '1' and '2' because `await p`</span>
  <span class="hljs-comment">// pauses the arrow functions, **not** `test()`</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done'</span>);
}
</code></pre>
<h3 id="make-sure-you-handle-errors-with-catch-">Make sure you handle errors with <code>.catch()</code></h3>
<p>Consolidated error handling is one of the most powerful features of async/await.
Using <code>asyncFn().catch()</code> handles all errors (sync and async) that occur
in <code>asyncFn()</code>. Remember example 3.4: <code>try/catch</code> does <em>not</em> handle async
errors in <code>return p</code> if <code>p</code> rejects.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.22</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Bad! Won't handle `return p` if `p` rejects</span>
  <span class="hljs-keyword">try</span> { <span class="hljs-comment">/* Complex logic */</span> } <span class="hljs-keyword">catch</span> (err) { handleError(err); }
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/* Complex logic */</span> }
fn2().catch(handleError); <span class="hljs-comment">// Better. Less repetition, more robust</span>
</code></pre>
<p>In general, any error in an async function should end up in a <code>.catch()</code>
handler. If you see async/await based code with no <code>.catch()</code> calls, there&#39;s
an unhandled error somewhere. Good async/await code uses some centralized
mechanism like a <code>wrap()</code> function to ensure every async function call gets
a <code>.catch()</code> at the end.</p>
<div class="example-header-wrap"><div class="example-header">Example 3.23</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> wrap = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Ensure function call has an error handler</span>
  <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error));
};
<span class="hljs-keyword">const</span> [fn1, fn2] = [
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'err1'</span>); },
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'err2'</span>); }
].map(wrap);
fn1(); <span class="hljs-comment">// Prints "err1"</span>
fn2(); <span class="hljs-comment">// Prints "err2"</span>
</code></pre>
<h1 id="exercise-1-implementing-custom-thenables">Exercise 1: Implementing Custom Thenables</h1>
<p>As you saw in example 3.2, all you need to integrate an object with async/await
is a <code>then()</code> function. The <code>await</code> keyword calls <code>then()</code> under the hood and
pauses the async function until <code>onFulfilled()</code> or <code>onRejected()</code> is called.
This means you can add a <code>then()</code> function to any object to make it work with
async/await.</p>
<p>Many JavaScript HTTP clients, like <a href="https://www.npmjs.com/package/superagent">superagent</a>, support a chainable
API for building up requests with function calls. Many ODMs and ORMs support
a similar API for building database queries.</p>
<pre><code class="lang-javascript">superagent.get(url).set(<span class="hljs-string">'API-Key'</span>, <span class="hljs-string">'test'</span>).
  end(<span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> { <span class="hljs-comment">/* Handle response */</span> });
</code></pre>
<p>The below <code>HTTPRequest</code> class provides a simplified HTTP client with a chainable
API, but currently it only supports callbacks via the <code>exec()</code> function.
Implement the <code>then()</code> function so this <code>HTTPRequest</code> class works with async/await.</p>
<p>Below is the starter code. You may copy this code and complete this exercise in
Node.js, or you may complete it in your browser
on CodePen at <a href="http://bit.ly/async-await-exercise-31"><code>http://bit.ly/async-await-exercise-31</code></a>.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTTPRequest</span> </span>{ <span class="hljs-comment">// Only modify the `then()` function below</span>
  <span class="hljs-keyword">static</span> create() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HTTPRequest(); }
  get(url) {
    <span class="hljs-keyword">this</span>.method = <span class="hljs-string">'get'</span>;
    <span class="hljs-keyword">this</span>.url = url;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
  exec(callback) {
    fetch(<span class="hljs-keyword">this</span>.url, <span class="hljs-keyword">this</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json()).
      then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> callback(<span class="hljs-literal">null</span>, res)).catch(callback);
  }
  then(onFulfilled, onRejected) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not Implemented'</span>); <span class="hljs-comment">// Implement this function</span>
  }
}
<span class="hljs-comment">// Don't modify the below code</span>
run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://'</span> +
    <span class="hljs-string">'us-central1-mastering-async-await.cloudfunctions.net/posts'</span>;
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> HTTPRequest.create().get(url);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success'</span>, res[<span class="hljs-number">0</span>].id === <span class="hljs-number">51</span>)
}
</code></pre>
<h1 id="exercise-2-async-foreach-">Exercise 2: Async <code>forEach()</code></h1>
<p>As shown in example 3.21, the <code>forEach()</code> array function has several quirks
when it comes to async/await:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// SyntaxError because `await` is not in an async function</span>
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> { <span class="hljs-keyword">await</span> p; });
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  [<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>), <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)].
    forEach(<span class="hljs-keyword">async</span> (p) =&gt; { <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> p); });
  <span class="hljs-comment">// "Done" prints **before** "1" &amp; "2", because the above `await`</span>
  <span class="hljs-comment">// pauses the above arrow function, **not** `fn2()`</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done'</span>);
}
</code></pre>
<p>Implement an async function <code>forEachAsync()</code> that takes an array
and an async function <code>fn()</code>, and calls <code>fn()</code> on every element of the array
in series. The <code>forEachAsync()</code> function should wait for one instance of <code>fn()</code>
to finish running before continuing on to the next one.</p>
<p>Below is the starter code. You may copy this code and complete this exercise in
Node.js, or you may complete it in your browser
on CodePen at <a href="http://bit.ly/async-await-exercise-32"><code>http://bit.ly/async-await-exercise-32</code></a>.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Implement this function</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachAsync</span>(<span class="hljs-params">arr, fn</span>) </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not Implemented!'</span>) }

<span class="hljs-comment">// Below is test code, don't modify this</span>
run().catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err.stack));
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">100</span> - n * <span class="hljs-number">10</span>));
    <span class="hljs-keyword">if</span> (i++ !== n) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Make sure to `await` on `fn()`'</span>);
  }
  <span class="hljs-keyword">await</span> forEachAsync(arr, fn1);
  <span class="hljs-keyword">if</span> (i !== <span class="hljs-number">10</span>) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Call `fn()` on every array element'</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success!'</span>);
}
</code></pre>

        </div>
        <div class="chapter">
          <h1 id="async-await-in-the-wild">Async/Await in the Wild</h1>
<p>Async/await is a powerful tool on its own, but it really shines when combined
with the prolific open source JavaScript ecosystem. It is no secret that
JavaScript was a painful language to work with in 2005, but that pain lead
developers to build an incredible variety of libraries and frameworks to
address common problems.</p>
<p>Now that JavaScript has features like async/await, these libraries and frameworks
are even more powerful.
In this chapter, you&#39;ll see how async/await interacts with several common
npm packages. In addition, you&#39;ll learn to evaluate whether a
package works with async/await.</p>
<p>Broadly speaking, npm packages belong to one of two categories when it comes
to integrating with async/await: libraries and frameworks.</p>
<ul>
<li>Generally, when working with a <em>framework</em>, like Express or Redux, you pass functions to the framework that the framework then calls for you.</li>
<li>Conversely, a <em>library</em>, like superagent or the MongoDB driver, exposes a collection of functions for you that you&#39;re responsible for calling.</li>
</ul>
<p>Not all npm packages fall neatly into one of these categories. But, these
categories help break the question of whether a given package &quot;works&quot;
with async/await down into two easier questions.</p>
<p>For a framework to support async/await, it must support functions that return
promises.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.1</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// Express is the most popular web framework for Node.js.</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();
<span class="hljs-comment">// Does Express handle functions that return promises?</span>
app.get(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">1000</span>));
  res.send(<span class="hljs-string">'Hello, World!'</span>);
});
</code></pre>
<p>For a library to support async/await, its functions must return thenables.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.2</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// Superagent is a popular HTTP client library for Node.js</span>
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error.stack));
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Do superagent's functions return thenables?</span>
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> superagent.get(<span class="hljs-string">'http://google.com'</span>);
}
</code></pre>
<p>Now let&#39;s apply these principles to several popular npm packages, starting
with the test framework <a href="http://npmjs.com/package/mocha">mocha</a>.</p>
<h1 id="with-mocha">With Mocha</h1>
<p>Mocha falls firmly into the framework category. It&#39;s a framework that runs
behavior-driven development (BDD) tests for you. The below example is from
the Mocha home page. It has one test that asserts that JavaScript&#39;s
built-in <code>indexOf()</code> function handles a simple case correctly.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.3</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);
describe(<span class="hljs-string">'Array'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  describe(<span class="hljs-string">'#indexOf()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    it(<span class="hljs-string">'should return -1 when the value is not present'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      assert.equal([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].indexOf(<span class="hljs-number">4</span>), <span class="hljs-number">-1</span>);
    });
  });
});
</code></pre>
<p>The <code>describe()</code> calls are analogous to test suites in more conventional
testing frameworks like <a href="https://junit.org/junit5/">JUnit</a>, and the <code>it()</code>
calls are individual tests. So Mocha&#39;s async/await support is contingent
on whether the <code>it()</code> function supports passing in a function that returns
a promise.</p>
<p>To figure out whether Mocha supports promises, go to their documentation site,
which has a <a href="https://mochajs.org/#working-with-promises">section on promises</a>
pictured below.</p>
<p><img src="https://i.imgur.com/dLnbbfs.png"></p>
<p>So Mocha does support async/await as a framework. Digging deeper, it turns out
Mocha has enjoyed <a href="https://github.com/mochajs/mocha/blob/master/CHANGELOG.md#1180--2014-03-13">rudimentary promise support since <code>v1.8.0</code> in March 2014</a>.</p>
<div class="page-break"></div>

<p>Below is an example of using Mocha with an async function.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.4</div></div>

<pre><code class="lang-javascript">describe(<span class="hljs-string">'async'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  it(<span class="hljs-string">'works'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>), <span class="hljs-number">42</span>);
  });
});
</code></pre>
<h1 id="with-express">With Express</h1>
<p><a href="http://expressjs.com/">Express</a> is a Node.js web framework used for building
HTTP servers, like RESTful APIs and classic web applications. The key term
here is that Express is primarily a framework, which means its async/await
support is predicated on supporting functions that return promises. Below is
an example showing how to use Express with synchronous functions.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.5</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();
app.get(<span class="hljs-string">'*'</span>, (req, res) =&gt; res.send(<span class="hljs-string">'Hello, World!'</span>));
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p>Since Mocha supports async/await out of the box, you might mistakenly assume
that Express supports async/await too. That would be a mistake. However, it is
an easy mistake to make because the below code works fine, even though the
Express route handler function is now async.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.6</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();
app.get(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; res.send(<span class="hljs-string">'Hello, World!'</span>));
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p>Figuring out that Express doesn&#39;t fully support async/await is tricky because
they don&#39;t explicitly say one way or the other in the docs. If you Google
&quot;express async/await&quot;, you&#39;ll end up at <a href="https://github.com/expressjs/express/issues/2259">an old GitHub issue</a> that&#39;s still open and
implies that promises are not quite supported.</p>
<p><img src="https://i.imgur.com/9afBtuL.png"></p>
<p>Unfortunately, this GitHub issue isn&#39;t explicit about where the interaction
between Express and async/await breaks down. The issue is what happens when
your async function throws an error.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.7</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)();
<span class="hljs-comment">// Process will crash, won't send a response</span>
app.get(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); });
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
<span class="hljs-comment">// This request will error out, but not with the 'Oops!' error</span>
<span class="hljs-keyword">const</span> request = superagent.get(<span class="hljs-string">'http://localhost:3000'</span>).end();
</code></pre>
<p>In older versions of Node.js, the superagent request above will hang. In newer
versions of Node.js, the Express server process will crash because Express
does <strong>not</strong> handle errors in promises.</p>
<p>Unfortunately, there is no way to make Express handle promises correctly without
monkey-patching Express itself or using a wrapper function. Using a wrapper
function is the better choice, because it is difficult to foresee all the
potential consequences of replacing part of a framework&#39;s code. Below is an
example of a wrapper function you can use to handle async function errors with
Express.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.8</div></div>

<pre><code class="lang-javascript">app.get(<span class="hljs-string">'*'</span>, wrap(<span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>); }));
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> superagent.get(<span class="hljs-string">'http://localhost:3000'</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-comment">// error.response.text === 'Oops!'</span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> fn(req, res).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (res.headersSent) {
      <span class="hljs-comment">// `headersSent` means Express has already started sending</span>
      <span class="hljs-comment">// an HTTP response, so we can't report the error via the</span>
      <span class="hljs-comment">// HTTP response. Depending on your app's needs, you may</span>
      <span class="hljs-comment">// choose to rethrow the error here, or ignore it.</span>
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// Error occurred, set the response status to 500 (Internal</span>
    <span class="hljs-comment">// Server Error) and send the error message.</span>
    res.status(<span class="hljs-number">500</span>).send(error.message);
  });
}
</code></pre>
<p>Error handling often causes async/await integration issues. Make sure to check
whether frameworks you use
handle errors in async function correctly. Express is not the only framework that seems to support async functions at first glance but does not
handle errors.</p>
<h1 id="with-mongodb">With MongoDB</h1>
<p>Mocha is an example of a framework that fully supports async functions and
Express is an example of a framework that does not support async functions.
Let&#39;s take a look at an example of a Node.js library: the
<a href="http://npmjs.com/package/mongodb">official MongoDB driver for Node.js</a>.</p>
<p>The MongoDB driver generally does not execute
functions for you, with a few exceptions like callbacks.
Apps built on the MongoDB driver primarily use the driver&#39;s functions for CRUD (create, read, update, delete) operations:</p>
<div class="example-header-wrap"><div class="example-header">Example 4.9</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { MongoClient } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>);
<span class="hljs-keyword">const</span> uri = <span class="hljs-string">'mongodb://localhost:27017/test'</span>;
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">await</span> MongoClient.connect(uri);
<span class="hljs-keyword">const</span> db = client.db(<span class="hljs-string">'test'</span>);

<span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'test'</span>).insertOne({ <span class="hljs-attr">answer</span>: <span class="hljs-number">42</span> }); <span class="hljs-comment">// Create</span>
<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'test'</span>).findOne(); <span class="hljs-comment">// Read</span>
<span class="hljs-built_in">console</span>.log(doc.answer); <span class="hljs-comment">// Prints "42"</span>
</code></pre>
<p>For a library to support async/await, its functions must return
thenables. The documentation shows that functions like
<code>insertOne()</code> return a promise, as long as you don&#39;t specify a callback.</p>
<p><img src="https://i.imgur.com/Cr8TuDT.png"></p>
<p>This means the MongoDB driver supports async/await from a library perspective.
However, using the MongoDB driver with async/await lets you do more than just
<code>await</code> on individual CRUD operations. Async/await opens up some elegant
alternatives for streaming data using <code>for</code> loops.</p>
<p>Most database applications only read a few documents from the database at a
time. But what happens if you need to read through millions of documents, more
than can fit into your application&#39;s memory at one time? The MongoDB driver
has a construct called a <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/Cursor.html">cursor</a> that lets you iterate through huge data sets by only loading a fixed number of
documents into memory at any one time.</p>
<p>Fundamentally, a MongoDB cursor is an object with a function <code>next()</code> that
returns a promise which resolves to the next document, or <code>null</code> if there are
no more documents. Without async/await, iterating through a cursor using
<code>next()</code> required recursion. With async/await, you can iterate through a
cursor using a <code>for</code> loop:</p>
<div class="example-header-wrap"><div class="example-header">Example 4.10</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">await</span> db.collection(<span class="hljs-string">'Movie'</span>).insertMany([
  { <span class="hljs-attr">title</span>: <span class="hljs-string">'Star Wars'</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">1977</span> },
  { <span class="hljs-attr">title</span>: <span class="hljs-string">'The Empire Strikes Back'</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">1980</span> },
  { <span class="hljs-attr">title</span>: <span class="hljs-string">'Return of the Jedi'</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">1983</span> }
]);
<span class="hljs-comment">// Do not `await`, `find()` returns a cursor synchronously</span>
<span class="hljs-keyword">const</span> cursor = db.collection(<span class="hljs-string">'Movie'</span>).find();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v = <span class="hljs-keyword">await</span> cursor.next(); v != <span class="hljs-literal">null</span>; v = <span class="hljs-keyword">await</span> cursor.next()) {
  <span class="hljs-built_in">console</span>.log(v.year); <span class="hljs-comment">// Prints "1977", "1980", "1983"</span>
}
</code></pre>
<p>That&#39;s right, you can <code>await</code> within a <code>for</code> loop&#39;s statements. This pattern
is a more intuitive and performant way to iterate through a cursor than using
recursion or streams.</p>
<h1 id="with-redux">With Redux</h1>
<p><a href="http://npmjs.com/package/react">React</a> is the most popular JavaScript UI framework, and <a href="https://www.npmjs.com/package/redux">Redux</a> is
the most popular state management framework for React. The two have become
largely synonymous since Redux&#39;s release in 2015. For the purposes of async/await
integration, both React and Redux are frameworks.</p>
<p>First, let&#39;s look at how to integrate Redux with async/await. Below is an
example of using Redux with synchronous functions in vanilla Node.js. Redux
has 3 primary concepts: stores, actions, and reducers. A <em>store</em> tracks the
state of your application, an <em>action</em> is an object representing some change
going through the system, and a <em>reducer</em> is a synchronous function that
modifies the application state object in response to actions.</p>
<div class="page-break"></div>

<p><br></p>
<div class="example-header-wrap"><div class="example-header">Example 4.11</div></div>

<pre><code class="lang-javascript"><span class="hljs-comment">// A _store_ tracks state and lets you dispatch _actions_</span>
<span class="hljs-keyword">const</span> { createStore } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'redux'</span>);
<span class="hljs-comment">// A _reducer_ is a sync function that changes the state</span>
<span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span>(action.type) { <span class="hljs-comment">// Redux calls reducer on every action</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>: <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>: <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">default</span>:          <span class="hljs-keyword">return</span> state;
  };
};
<span class="hljs-comment">// Create a new store and subscribe to state changes</span>
<span class="hljs-keyword">const</span> store = createStore(reducer, <span class="hljs-number">0</span>);
store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(store.getState()));

store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> }); <span class="hljs-comment">// Prints "1"</span>
store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> }); <span class="hljs-comment">// Prints "2"</span>
store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'DECREMENT'</span> }); <span class="hljs-comment">// Prints "1"</span>
</code></pre>
<p>Redux beginners might be wondering why you need to dispatch actions rather than
modifying the state directly using the assignment operator.
Watching for changes on a JavaScript value is hard, so
actions exist to make it easy to observe all changes going through the system.
In particular, Redux makes it easy to update your React UI every time your state
changes.</p>
<p>So can you use async/await with Redux? Redux
reducers <strong>must</strong> be synchronous, so you cannot use an async function as a
reducer. However, you can dispatch actions
from an async function.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.12</div></div>

<pre><code class="lang-javascript">store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(store.getState()));

run().catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error.stack));
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> }); <span class="hljs-comment">// Prints "1"</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve));
  store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> }); <span class="hljs-comment">// Prints "2"</span>
}
</code></pre>
<p>Calling <code>store.dispatch()</code> from an async function works, but
doesn&#39;t toe the Redux party line. The <a href="https://redux.js.org/advanced/async-actions#async-action-creators">official Redux approach</a> is to use the <code>redux-thunk</code> package and action creators. An <em>action creator</em> is
a function that returns a function with a single parameter,
<code>dispatch</code>.</p>
<div class="page-break"></div>

<p><br></p>
<div class="example-header-wrap"><div class="example-header">Example 4.13</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { createStore, applyMiddleware } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'redux'</span>);
<span class="hljs-keyword">const</span> thunk = <span class="hljs-built_in">require</span>(<span class="hljs-string">'redux-thunk'</span>).default;
<span class="hljs-comment">// The 3rd arg to `createStore()` is composed Redux _middleware_</span>
<span class="hljs-keyword">const</span> store = createStore(reducer, <span class="hljs-number">0</span>, applyMiddleware(thunk));
store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(store.getState()));

<span class="hljs-comment">// `redux-thunk` lets you dispatch _action creators_, which are</span>
<span class="hljs-comment">// potentially async functions that can `dispatch()` more actions</span>
store.dispatch(<span class="hljs-keyword">async</span> (dispatch) =&gt; {
  dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> }); <span class="hljs-comment">// Prints "1"</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve));
  dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> }); <span class="hljs-comment">// Prints "2"</span>
});
</code></pre>
<p><code>redux-thunk</code>&#39;s purpose is inversion of control (IoC). In other
words, an action creator that takes <code>dispatch()</code> as a parameter doesn&#39;t have
a hard-coded dependency on any one Redux store. Like AngularJS dependency
injection, but for React.</p>
<h1 id="with-react">With React</h1>
<p>Redux is best with React, the most popular UI framework for JavaScript. To avoid bloat, this chapter will not use JSX,
React&#39;s preferred extended JS syntax. Below is an example of creating a component
that shows &quot;Hello, World!&quot; in React:</p>
<div class="example-header-wrap"><div class="example-header">Example 4.14</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { renderToString } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom/server'</span>);
<span class="hljs-keyword">const</span> { createElement, Component } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'Hello, World!'</span>);
  }
}
<span class="hljs-comment">// &lt;h1 data-reactroot=""&gt;Hello, World!&lt;/h1&gt;</span>
<span class="hljs-built_in">console</span>.log(renderToString(createElement(MyComponent)));
</code></pre>
<p>Currently, <code>render()</code> functions <strong>cannot</strong> be async. An async <code>render()</code> will cause React to throw a &quot;Objects are not valid as a React child&quot; error. The
upcoming <a href="https://auth0.com/blog/time-slice-suspense-react16/">React Suspense API</a>
may change this.</p>
<p>React components have <a href="https://reactjs.org/docs/react-component.html">lifecycle hooks</a> that React calls when it
does something with a component. For example, React calls <code>componentWillMount()</code> before adding a component to the DOM. The below script
will also generate HTML that shows &quot;Hello, World!&quot; because <code>componentWillMount()</code>
runs before the first <code>render()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.15</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  componentWillMount() { <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">v</span>: <span class="hljs-string">'Hello, World!'</span> }); }
  render() { <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.state.v); }
}
<span class="hljs-comment">// &lt;h1 data-reactroot=""&gt;Hello, World!&lt;/h1&gt;</span>
<span class="hljs-built_in">console</span>.log(renderToString(createElement(MyComponent)));
</code></pre>
<p>The <code>componentWillMount()</code> hook does <strong>not</strong>
handle async functions. The below
script produces an empty <code>&lt;h1&gt;</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.16</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">async</span> componentWillMount() {
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span> });
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve));
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">text</span>: <span class="hljs-string">'Hello, World!'</span> });
  }
  render() { <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.state.text); }
}
<span class="hljs-comment">// &lt;h1 data-reactroot=""&gt;&lt;/h1&gt;</span>
<span class="hljs-built_in">console</span>.log(renderToString(createElement(MyComponent)));
</code></pre>
<p>React also doesn&#39;t
handle errors that occur in an async <code>componentWillMount()</code>.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.17</div></div>

<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">async</span> componentWillMount() {
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span> });
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setImmediate(resolve));
    <span class="hljs-comment">// Unhandled promise rejection</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops'</span>);
  }
  render() { <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.state.text); }
}
<span class="hljs-comment">// &lt;h1 data-reactroot=""&gt;&lt;/h1&gt;</span>
<span class="hljs-built_in">console</span>.log(renderToString(createElement(MyComponent)));
</code></pre>
<p>In general, React doesn&#39;t handle async functions well. Even though
async <code>componentWillMount()</code> works in the browser, React won&#39;t handle errors
and there&#39;s no way to <code>.catch()</code>. To use async functions
with React, you should use a framework like Redux. The following is an example of
using Redux action creators with React.</p>
<p><br></p>
<div class="example-header-wrap"><div class="example-header">Example 4.18</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> <span class="hljs-built_in">Object</span>.assign({}, state, action);
<span class="hljs-keyword">const</span> store = createStore(reducer, { <span class="hljs-attr">v</span>: <span class="hljs-string">''</span> }, applyMiddleware(thunk));

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  componentWillMount() { <span class="hljs-keyword">this</span>.setState(store.getState()); }
  render() { <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.state.v); }
}

store.dispatch(<span class="hljs-keyword">async</span> (dispatch) =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">250</span>));
  dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'SET'</span>, <span class="hljs-attr">v</span>: <span class="hljs-string">'Hello, World!'</span> });
});
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// First 2 will print an empty &lt;h1&gt;, then "Hello, World!"</span>
  <span class="hljs-built_in">console</span>.log(renderToString(createElement(MyComponent)));
}, <span class="hljs-number">100</span>);
</code></pre>
<p>Unfortunately, <code>redux-thunk</code> doesn&#39;t handle errors in async action creators
for you. But, since the action creator is a function as opposed to a class
method, you can handle errors using a wrapper function like in Example 4.8.
For React and Redux, the wrapper function should <code>dispatch()</code> an error action
that your UI can then handle.</p>
<div class="example-header-wrap"><div class="example-header">Example 4.19</div></div>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> wrap = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> dispatch =&gt; {
  fn(dispatch).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'ERROR'</span>, error }));
};

store.dispatch(wrap(<span class="hljs-keyword">async</span> (dispatch) =&gt; {
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="hljs-number">250</span>));
  dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'SET'</span>, <span class="hljs-attr">v</span>: <span class="hljs-string">'Hello, World!'</span> });
}));
</code></pre>
<p>For frameworks that lack good async/await support, like React, Redux, and Express,
you should use wrapper functions to handle errors in a way
that makes sense for the framework. Be wary of plugins that monkey-patch the
framework to support async/await. But, above all, make sure you handle errors
in your async functions, because not all frameworks will do that for you.</p>
<div class="page-break"></div>

<h1 id="exercise-1-does-x-support-async-await-">Exercise 1: Does X Support Async/Await?</h1>
<p><a href="https://www.npmjs.com/package/agenda">Agenda</a> is an npm module that lets you
schedule jobs to run at certain times. Below is the documentation for Agenda&#39;s
<code>schedule()</code> function. Does the <code>schedule()</code> function support async/await
from a library perspective?</p>
<h3 id="schedule-when-name-data-cb-">schedule(when, name, [data], [cb])</h3>
<p>Schedules a job to run <code>name</code> once at a given time. <code>when</code> can be a <code>Date</code> or a
<code>String</code> such as <code>tomorrow at 5pm</code>.</p>
<p><code>data</code> is an optional argument that will be passed to the processing function
under <code>job.attrs.data</code>.</p>
<p><code>cb</code> is an optional callback function which will be called when the job has been
persisted in the database.</p>
<p>Returns the <code>job</code>.</p>
<pre><code class="lang-js">agenda.schedule(<span class="hljs-string">'tomorrow at noon'</span>, <span class="hljs-string">'printAnalyticsReport'</span>, {
  <span class="hljs-attr">userCount</span>: <span class="hljs-number">100</span>
});
</code></pre>
<p>Optionally, <code>name</code> could be array of job names, similar to <code>every</code> method.</p>
<pre><code class="lang-js">agenda.schedule(<span class="hljs-string">'tomorrow at noon'</span>, [
  <span class="hljs-string">'printAnalyticsReport'</span>,
  <span class="hljs-string">'sendNotifications'</span>,
  <span class="hljs-string">'updateUserRecords'</span>
]);
</code></pre>
<p>In this case, <code>schedule</code> returns array of <code>jobs</code>.</p>
<div class="page-break"></div>

<h1 id="exercise-2-websocket-integration">Exercise 2: WebSocket Integration</h1>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>
are a tool for real-time communication between a browser and a server. Without
WebSockets, a server can&#39;t send data to a browser unless the browser makes an
HTTP request. With a WebSocket connection, a server can push data to the browser.</p>
<p>The key function for interacting with a WebSocket is the <code>onmessage</code> function,
which JavaScript calls for you when the socket has new data to process.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'wss://echo.websocket.org/'</span>);

ws.onmessage = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Got'</span>, e.data);
</code></pre>
<p>JavaScript
does <strong>not</strong> handle errors that occur in <code>onmessage</code> if <code>onmessage</code> is async.
Write a function that wraps async <code>onmessage</code> functions and logs any errors
that occur to the console.</p>
<p>Below is the starter code. You may copy this code and complete this exercise in
Node.js, although you will need the <a href="https://github.com/heineiuo/isomorphic-ws"><code>isomorphic-ws</code> npm module</a> because Node.js does <strong>not</strong>
have WebSockets. You may complete also complete it in your browser
on CodePen at <a href="http://bit.ly/async-await-exercise-32"><code>http://bit.ly/async-await-exercise-42</code></a>.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Implement this function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">onmessage</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Not implemented'</span>)
}

<span class="hljs-comment">// Do not modify the below code</span>
<span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'wss://echo.websocket.org/'</span>);

ws.onmessage = wrap(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Congratulations, you completed this exercise!'</span>);
});

ws.onopen = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ws.send(<span class="hljs-string">'Hello, World'</span>);
ws.onclose = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'disconnected'</span>);
</code></pre>

        </div>
        <div class="chapter">
          <h1 id="moving-on">Moving On</h1>
<p>Async/await is an exciting new tool that makes JavaScript much easier to
work with. Async/await won&#39;t solve all your problems, but it will make your
day-to-day easier by replacing callbacks and promise chaining with <code>for</code> loops
and <code>if</code> statements. But remember the fundamentals, or you&#39;ll end up trading
callback hell and promise hell for async/await hell.
Here are some key points to remember when working with async/await.</p>
<ul>
<li>An async function always returns a promise.</li>
<li><code>await</code> pauses an async function until the awaited promise is settled.</li>
<li><code>await</code> on a value that isn&#39;t a promise is a no-op.</li>
<li>Other JavaScript may run when an async function is paused.</li>
<li>Error handling is a common problem. Make sure you handle errors with <code>.catch()</code>.</li>
</ul>
<p>To get more content on async/await, including design patterns and tools for
integrating with popular frameworks, check out my blog&#39;s async/await section
at <a href="http://bit.ly/asyncawait-blog"><code>bit.ly/asyncawait-blog</code></a>.</p>
<p>Congratulations on completing this book, and good luck with your async/await
coding adventures!</p>

        </div>
      </body>
    </html>
  